- Your Highlight on page 37 | location 565-566 | Added on Thursday, 22 June 2023 08:27:34

Slow down. The more you understand, the less you have to memorize.
- Your Highlight on page 38 | location 569-570 | Added on Thursday, 22 June 2023 08:27:43

Do the exercises. Write your own notes.
- Your Highlight on page 38 | location 573-573 | Added on Thursday, 22 June 2023 08:28:02

Read the “There Are No Dumb Questions.”
- Your Highlight on page 38 | location 576-576 | Added on Thursday, 22 June 2023 08:28:13

Make this the last thing you read before bed. Or at least the last challenging thing.
- Your Highlight on page 38 | location 580-580 | Added on Thursday, 22 June 2023 08:28:32

Talk about it. Out loud.
- Your Highlight on page 58 | location 886-887 | Added on Tuesday, 27 June 2023 07:28:10

Creating a Git repository involves running the git init command inside the top folder of your project.
- Your Highlight on page 75 | location 1139-1140 | Added on Thursday, 29 June 2023 19:07:21

The first thing to know is that only the files that you add are committed.
- Your Highlight on page 76 | location 1154-1157 | Added on Thursday, 29 June 2023 19:10:00

The commit object does not actually store your changes—well, not directly, anyway. Instead, Git stores your changes in a different location in the Git repository and simply records (in the commit) where your changes have been stored. Along with recording where it stored your changes, the commit records a bunch of other details: A pointer to the location inside the .git folder where Git has stored your changes, called a tree.
- Your Highlight on page 77 | location 1168-1169 | Added on Thursday, 29 June 2023 19:22:22

Commit objects are stored by Git in binary format, making them very hard for humans to read but super safe and efficient for Git.
- Your Highlight on page 77 | location 1175-1181 | Added on Thursday, 29 June 2023 19:25:10

The Git repository itself is divided into two parts—the first part is called the “index,” and the second part is what we will refer to as the “object database.” When we run git add <filename>, Git makes a copy of the file and puts it in the index. We can think of the index as the “staging area,” wherein we can put things till we are sure we want to commit to them. Now when we run the git commit command, it takes the contents of the staging area and stores those in the object database, also known as Git’s memory bank. To put it another way, the index is a place to temporarily house changes. Typically, you make some changes, add them to the index, and then decide if you are ready to commit—if yes, then you make a commit. Otherwise, you can continue making changes, add more changes to the staging area, and then when you feel you are in a good place, commit.
- Your Highlight on page 81 | location 1228-1238 | Added on Monday, 13 November 2023 21:05:07

A peek behind the curtain We are going to let you in on Git’s little secret. When you add (one or more files) to Git’s index, Git doesn’t touch any of the files in your working directory. Instead, it copies the contents of those files to the index. This is an important point because it is crucial to how Git tracks the content of our files. NOTE We alluded to this in the previous pages. So what happens when we commit? Well, as we know, Git takes the contents of the index, tucks those safely into its memory bank, and represents that version with a commit object. This means that now Git has a third copy of your files contents in its object database! There can be up to three copies of any file in your working directory.
- Your Highlight on page 81 | location 1240-1243 | Added on Monday, 13 November 2023 21:05:38

Git looks like: you make some edits to one or more files, then add them to the index, and when you are ready, you commit them. Now, as you are going through this workflow, Git is attempting to track the state of your files so it knows which files are part of your working directory, which files have been added to the index, and which files have already been committed to its object store. Throughout, keep in mind that Git is moving copies of your file from the working directory, to the index, to its object database.
- Your Highlight on page 82 | location 1244 | Added on Monday, 13 November 2023 21:06:30


- Your Highlight on page 82 | location 1248-1250 | Added on Friday, 17 November 2023 09:05:45

A file that Git has never seen before (that is, a file that has never been added to the index) is marked as “untracked.” Adding the file to the index is our way of telling Git, “Hey! We’d really like you to keep an eye on this file for us.” Any file that Git is watching for us is referred to as a “tracked” file.
- Your Highlight on page 82 | location 1252-1256 | Added on Friday, 17 November 2023 09:08:09

consider adding a file to the index and then immediately making a commit. Git stores the contents of the index in its object database and then marks the file as “unmodified.” Why unmodified, you ask? Well, Git compares the copy it has in its object database with the one in the index and sees they are the same. It also compares the copy in the index with the one in the working directory and sees that they are the same. So the file has not been modified (or is unmodified) since the last commit.
- Your Highlight on page 82 | location 1256 | Added on Friday, 17 November 2023 09:09:08


- Your Highlight on page 82 | location 1257-1259 | Added on Friday, 17 November 2023 09:09:32

if we were to make a change to a file that we had previously committed, Git sees a difference between the file in the working directory and the index but no difference between the index and the object database. So Git marks the file as “modified,” but it also marks it as “not staged” because we haven’t added it to the index yet.
- Your Highlight on page 83 | location 1260 | Added on Friday, 17 November 2023 09:10:03


- Your Highlight on page 83 | location 1264 | Added on Friday, 17 November 2023 09:10:25


- Your Highlight on page 83 | location 1266-1267 | Added on Friday, 17 November 2023 09:10:45

Recall that any file in your working directory is either untracked or tracked. Also, a tracked file can be either staged, unmodified, or modified.
- Your Highlight on page 86 | location 1311-1313 | Added on Friday, 17 November 2023 09:14:18

Now if you add the file again, Git overwrites the index with the latest changes reflected in that file. In other words, the index is a temporary scratch pad—one you can use to stuff edits into till you are sure you want to commit.
- Your Highlight on page 86 | location 1309-1313 | Added on Friday, 17 November 2023 09:14:29

Of course, we can continue editing the file even after adding it to the index. Now, we have two versions of the file—one in the working directory and one in the index. Now if you add the file again, Git overwrites the index with the latest changes reflected in that file. In other words, the index is a temporary scratch pad—one you can use to stuff edits into till you are sure you want to commit.
- Your Highlight on page 93 | location 1415-1419 | Added on Friday, 12 January 2024 15:06:15

There is one final detail about commits that you ought to know about. For every commit that you make (other than the very first one in a repository), the commit also records the commit ID of the commit that came just before it. That is to say, the commits form a chain, much like the branch of a tree, or a string of Christmas lights. This means, given a commit ID, Git can trace its lineage by simply following the “parent” pointer. This is referred to as the commit history and is an integral piece to how Git works.
- Your Highlight on page 94 | location 1427-1429 | Added on Friday, 12 January 2024 15:07:39

The Git commit history is often referred to as a directed acyclic graph, or DAG for short, wherein the commits form the “nodes” and the pointers to the parent form the “edges.” They are directed because children point to parent, and acyclic because parents do not point back to their children.
- Your Highlight on page 95 | location 1456-1459 | Added on Friday, 12 January 2024 15:09:22

A brand new file added to the working directory is marked as “untracked,” which suggests that Git does not know about this file. Adding a new file to Git’s index does two things—it marks the file as being “tracked” and creates a copy of that file into the index.
- Your Highlight on page 100 | location 1525-1531 | Added on Friday, 12 January 2024 15:12:15

You create a new file in the repository called Hello.txt. You add Hello.txt to the index (using git add). You commit all the changes that you staged (using git commit). You edit Hello.txt with some new content. 
- Your Highlight on page 110 | location 1676-1680 | Added on Saturday, 13 January 2024 15:28:54

git switch is a relatively new command. If you get an error like “switch is not a git command”, be sure to check the version of Git you have installed with git version. You need to have a version greater than 2.23.0. Older versions of Git used the git checkout command to switch branches. While that still works, we prefer to show you the latest (and now correct) way to do things.
- Your Highlight on page 118 | location 1807-1811 | Added on Sunday, 14 January 2024 12:19:02

What is a branch, really? Say it with us—a branch is simply a reference to a commit. So what makes a branch a branch? Let’s start with the role of a commit—a commit is a snapshot of the content you staged (that is, the files you added to the index). If you happen to be working on a task in which you have made two or more commits, then the commits are “strung” together. That is, every subsequent commit records the ID of the commit that came just before it.
- Your Highlight on page 119 | location 1819-1820 | Added on Sunday, 14 January 2024 12:21:20

A branch is simply a reference to a commit via its ID. This reference is updated every time you make another commit on that branch.
- Your Highlight on page 120 | location 1839-1841 | Added on Sunday, 14 January 2024 12:24:29

Every time you switch branches, Git rewrites your working directory to look like it did when you made the most recent commit on the branch you just switched to.
- Your Highlight on page 121 | location 1844-1846 | Added on Sunday, 14 January 2024 12:30:29

This is particularly important if you have files open in your editor. It’s a good idea to either refresh the files in your editor or simply reopen the project after switching branches so you see the latest set of files.
- Your Highlight on page 123 | location 1882-1883 | Added on Sunday, 14 January 2024 12:35:25

Merging in Git typically involves two branches—the branch that you are on (we’ll refer to this as the “proposer”) and the branch you wish to merge or “mix” in (we’ll call this the “proposee”).
- Your Highlight on page 126 | location 1928-1929 | Added on Sunday, 14 January 2024 19:59:23

Here is your memory trick of the day: “--help” has more characters in it than “-h”, just as the --help page has more characters and details than the -h page.
- Your Highlight on page 130 | location 1979-1992 | Added on Sunday, 14 January 2024 20:26:05

Some merges are fast-forward When you merge two branches together, you are combining the work done in the individual branches: that is, you are bringing together two separate commit histories. You might have also noticed the “fast-forward” that appeared in your terminal output when you performed the merge between the master and the add-fall-menu branch. So what did Git actually do? Let’s start with the commit history, focusing only on master and add-fall-menu. For simplicity we’ll use letters in alphabetical order to represent the commit IDs. It looks something like this. In this scenario, we have two sticky notes to represent the two branches, each one pointing to the latest commit on that branch. The thing to notice here is that the add-fall-menu branch is based on the latest commit on the master branch. The master branch has not changed (no new commits on it) since the inception of the add-fall-menu branch. In other words, the add-fall-menu branch has everything the master branch does! Which means, for Git to make master (the proposer) look like add-fall-menu, Git could simply move master to the same commit as the last commit on the add-fall-menu branch. That is exactly what Git does. Git rewrites the master sticky note to point to the same commit that the add-fall-menu sticky note points to. This is referred to as a “fast-forward” merge—where a branch, in this case master, simply jumps forward.
- Your Highlight on page 130 | location 1993-1996 | Added on Sunday, 14 January 2024 20:28:37

When merging, the fast-forward merge is the best-case scenario, since technically it’s not a merge at all. It’s simply one branch “catching up” with another. Look back and study the commit IDs you listed on the previous page. Notice that the add-fall-menu branch and the master branch both point to the same commit after the merge.
- Your Highlight on page 138 | location 2116-2119 | Added on Sunday, 14 January 2024 20:54:22

It’s a merge commit We know, you are brimming with questions! Is this merge any different from our last merge? If it is, why? We have never seen an editor pop up to ask for a commit message before, so what’s different now?
- Your Highlight on page 139 | location 2127-2131 | Added on Sunday, 14 January 2024 20:58:51

When we try to merge add-thurs-menu into master, Git has to reconcile two different sets of changes into one. So Git pulls a fast one—it creates a new commit for us that represents the combined work from both branches. Here is what your commit history looks like before and after the merge: Notice
- Your Highlight on page 141 | location 2157-2163 | Added on Monday, 15 January 2024 09:27:42

A merge commit is like any other commit you have created so far. It records the work that resulted from bringing two branches together, along with some metadata. The metadata includes your name and email, the time when the commit was created, and the commit message you supplied when we performed the merge. Also, every commit (other than the very first one in a repository) records the ID of the commit that preceded it. However, merge commits have a few interesting characteristics. For one thing, remember that you did not create this commit explicitly—rather, Git did, when it merged two branches that had diverged away from one another. For another thing, a merge commit has two parents—the first parent is the last commit on the branch that is the proposer, and the second parent is the last commit from the proposee branch that was merged in. Looking back at the 80s-diner commit history:
- Your Highlight on page 143 | location 2182-2187 | Added on Monday, 15 January 2024 09:30:40

Merge conflicts result when we attempt to bring together commits that affect the same files in different ways. This is similar to our alternate universes crashing into one another—when that happens, how will you reconcile your humanitarian and villain selves? One such scenario is the one we just described—we have the same file in two different branches, continue to treat the master branch as the integration branch, and merge feat-a into the master branch. What happens? Git throws its hands up in surrender! Git has absolutely no way of determining which version to keep, so it stops the merge midway and reports a merge conflict.
- Your Highlight on page 144 | location 2203-2204 | Added on Monday, 15 January 2024 10:10:01

Now it’s just a question of editing the files that have merge conflicts. You have four options....
- Your Highlight on page 145 | location 2209-2214 | Added on Monday, 15 January 2024 10:10:38

When you have a merge conflict, you have four choices. You can pick the changes introduced in the master branch, the changes in the feat-a branch, pick both (in this particular case), or ignore both and write something new altogether! Remember that the markers that Git put in there are just to highlight the conflicts—they are just there to help you out. Once you choose, this is what the file should look like: Your options: 
- Your Highlight on page 148 | location 2270-2271 | Added on Monday, 15 January 2024 19:04:34

First things first: you can’t delete the branch that you are on! So if you happen to be on the branch you are about to delete, you need to switch to another branch.
- Your Highlight on page 149 | location 2280-2282 | Added on Monday, 15 January 2024 19:05:22

If you suddenly realize you deleted the wrong branch, you can use a variation of the git branch command that lets you supply it the commit ID the branch should be based on, like so: git branch <branch-name> <base-commit-id>. This will allow you to undo an accidental delete.
- Your Highlight on page 151 | location 2308-2316 | Added on Monday, 15 January 2024 19:10:21

Take a moment to think about what your commit history looks like after you finish merging: When you delete the feat-a branch, all Git does is to throw away the sticky note that represents the feat-a branch. As for commit “B”: notice that the merge commit “D” has two parents, “C” and “B,” and the master branch sticky note points to commit “D.” So “B” sticks around because your commit history needs it. (Remember, it acts as the second parent of commit “D.”) The thing to remember is that as long as a commit is “reachable”—that is, there is a reference to it (like a branch) or another commit pointing to it as a parent—it will stay in your commit history. In this case, the master branch points to commit “D,” and “D” points to “B.” So commit “B” stays. You can extend this logic to “A” as well—because it has two commits referencing it—“B” and “C.”
- Your Highlight on page 152 | location 2317-2329 | Added on Monday, 15 January 2024 19:11:42

Deleting unmerged branches You now understand the impact of deleting branches. Which is, if the branch you are deleting has been merged, then your commit history does not change! Only the sticky note that represents the branch disappears. But what if you try to delete a branch that hasn’t been merged yet? Let’s look at another hypothetical commit history where we have two branches, master and feat-b, but we haven’t merged them together yet. Notice that there is a commit “B” on the feat-b branch. Now, if we tried to delete the feat-b branch, this is what you’d see: Git notices that if you were to delete the feat-b branch, commit “B” would not be reachable. In other words, there is nothing (a sticky note, or another commit) referencing it. And so it refuses to! Now there is a chance that you created a branch just to try out an idea or approach a problem using a different tack, and you don’t care for it anymore. You can supply the branch command with the -D (yep, uppercase D) flag to force its deletion. NOTE Git will display the ID of the latest commit of the branch that you force deleted, so you can always recover it like we showed you a few pages ago.
- Your Highlight on page 156 | location 2388-2391 | Added on Monday, 15 January 2024 22:21:38

The easiest kind of merge is called a “fast-forward merge,” in which one branch simply “catches up” with another branch. The other kind of merge is when you merge two branches that have diverged from one another, in which case Git will create a merge commit.
- Your Highlight on page 156 | location 2392-2393 | Added on Monday, 15 January 2024 22:21:50

A merge commit is like any other commit, except it’s created by Git and has not one but two parents—the first parent is the latest commit on the integration branch, and the second parent is the latest commit on the feature branch.
- Your Highlight on page 157 | location 2398-2403 | Added on Monday, 15 January 2024 22:22:20

If you attempt to delete a branch that has not been merged yet, Git will error out. If you are absolutely sure you want to delete an unmerged branch, you’ll have to use the -D (uppercase “D”) flag with the git branch command. A branch is always based on a commit. If you know the ID of the commit you want to use as the basis for a branch, you can supply it to the git branch command: git branch branch-name commit-ID
- Your Highlight on page 175 | location 2678 | Added on Tuesday, 16 January 2024 16:49:30


- Your Highlight on page 177 | location 2703-2711 | Added on Wednesday, 17 January 2024 22:23:16

How does git log work? What happens when Brigitte looks at the log of her repository? Consider a hypothetical commit history—it is made up of three branches—master, feat-a, and feat-b. Suppose Brigitte is on the feat-a branch and executes the git log command: Since Brigitte is on the feat-a branch, which points to commit “C,” the output of the git log command starts with C. It then reads and displays the details of that commit. It sees that “B” is C’s parent, so it does the same for “B.” After displaying the details of commit “B,” Git proceeds to commit “A” since that is the parent commit of “B.” However, “A” is the first commit made in this repository, and it has no parent, so it stops. 
- Your Highlight on page 177 | location 2713-2721 | Added on Wednesday, 17 January 2024 22:24:08

Enough with the suspense! Let’s see what it takes Brigitte to see all her commits across all the branches in her repository. If you guessed more flags, then ding, ding, ding—you win the prize! We know we like the --oneline flag—this time around we are going to add two more flags, namely --all and --graph. The --all flag does exactly what it says on the tin—it displays all branches in the repository. The --graph flag asks the git log command to display the commits as a graph. This is how we use it: NOTE This graph is the “directed acyclic graph” that we mentioned in Chapter 1. We’ve come full circle! 
- Your Highlight on page 181 | location 2764-2768 | Added on Wednesday, 17 January 2024 22:28:35

And remember—Git only knows what a file looks like if it’s tracking the file, in that, at some point, you either added a particular file to Git’s index, or committed it. NOTE We talked about untracked and tracked files in Chapter 1.
- Your Highlight on page 182 | location 2781-2783 | Added on Wednesday, 17 January 2024 22:31:22

Running git diff in a repository compares the version that Git has in its index with the version of the file in the working directory. This ordering is important! You can think of it as the version in the index being the “old” version and the version in the working directory being the “new” version.
- Your Highlight on page 182 | location 2790-2791 | Added on Wednesday, 17 January 2024 22:35:21

To put a button on it—the git diff command’s output is one file at a time, divvied up into separate areas of changes, each called a hunk. Next, let’s zoom in.
- Your Highlight on page 183 | location 2799-2802 | Added on Wednesday, 17 January 2024 22:38:53

Next up on the agenda are two lines that you can think of as a legend—the git diff command output is telling us that if we see a line prefixed with a “-”, that line belongs to the “a” (old) version of the resume.md file. And any line prefixed with a “+” is from the “b” (new) version of the file. 
- Your Highlight on page 185 | location 2826-2828 | Added on Wednesday, 17 January 2024 22:45:52

It has a command called difftool that shows changes using external diff tools. It also allows you to configure which tool it should use to compare files. You can use git difftool --tool-help to see the flags available, and also to configure Git to use a particular tool to display diffs. However, in this book we are going to stick to the tools that Git gives you out of the box.
- Your Highlight on page 185 | location 2835-2838 | Added on Wednesday, 17 January 2024 22:55:52

Making diffs easier on the eyes Most Git commands offer several flags. We’ve already seen a few that are available for the git log command. There is one flag you might want to consider that makes looking at diffs easier: 
- Your Highlight on page 187 | location 2861-2865 | Added on Wednesday, 17 January 2024 23:01:44

Diffing staged changes The default behavior of the git diff command is to compare the contents of the files in the index with the contents of the working directory and show you the differences. Now, Brigitte has already added all the files in the working directory to the index. This is the state of the files in her repository: 
- Your Highlight on page 187 | location 2861-2870 | Added on Wednesday, 17 January 2024 23:07:23

Diffing staged changes The default behavior of the git diff command is to compare the contents of the files in the index with the contents of the working directory and show you the differences. Now, Brigitte has already added all the files in the working directory to the index. This is the state of the files in her repository: Because the contents of the working directory and the index are identical since Brigitte added all the files to the index, the git diff command reports no difference. So how does she know what she is going to commit? Brigitte can still use the git diff command to compare the contents she had in her last commit with the index, except this time she will need to supply the “--cached” flag: When she runs this, the output she gets is shown below. 
- Your Highlight on page 187 | location 2861-2873 | Added on Wednesday, 17 January 2024 23:08:20

Diffing staged changes The default behavior of the git diff command is to compare the contents of the files in the index with the contents of the working directory and show you the differences. Now, Brigitte has already added all the files in the working directory to the index. This is the state of the files in her repository: Because the contents of the working directory and the index are identical since Brigitte added all the files to the index, the git diff command reports no difference. So how does she know what she is going to commit? Brigitte can still use the git diff command to compare the contents she had in her last commit with the index, except this time she will need to supply the “--cached” flag: When she runs this, the output she gets is shown below. Notice that the output isn’t so different from the first time she ran git diff (with no flag). The most significant difference between git diff and git diff --cached is that in the case of the former, we are comparing the index with the working directory; in the second, we are comparing the previously committed version with the index.
- Your Highlight on page 190 | location 2910-2913 | Added on Wednesday, 17 January 2024 23:12:55

If Brigitte wants to merge the add-skills branch into the edit-per-scotty branch, then it makes sense to have the add-skills branch as a “source” and the edit-per-scotty branch as the “target.” To compare the two, specifying edit-per-scotty first makes it the target, and add-skills second makes it the source.
- Your Highlight on page 191 | location 2915-2918 | Added on Wednesday, 17 January 2024 23:13:27

A branch is used to capture a single unit of work. Often, you’ll make several commits on the same branch before you are ready to merge your work into another branch. So what does it mean when Brigitte compares the add-skills branch to the edit-per-scotty branch? When you compare two branches, Git simply compares the latest commits on each branch—often referred to as the tips of the branches.
- Your Highlight on page 192 | location 2936-2941 | Added on Wednesday, 17 January 2024 23:18:18

Q: I recall seeing the “a” and “b” file markers in our earlier experiments with the git diff command. Do those represent sets of changes as well? A: Yes! Whenever you run the git diff command, you always have two “sets” of changes that you are comparing. When you run git diff (with no arguments) you are comparing the index (marked as “a”) with the working directory (marked as “b”). Similarly, when you run git diff --cached, the object database is marked as “a” and the index marked as “b.” Feel free to revisit our earlier experiments with git diff and git diff --cached and see how the Venn diagram analogy works there as well.
- Your Highlight on page 193 | location 2951-2958 | Added on Wednesday, 17 January 2024 23:21:18

Suppose you run this:   git diff add-skills  as compared to    git diff edit-per-scotty add-skills Since Git was only supplied one branch in the version on the left, it assumes you want to compare that branch with the working directory! That is, you are no longer comparing two branches. Instead, you are comparing the branch you supplied with the current state of your working directory. Furthermore, the order is now flipped!
- Your Highlight on page 210 | location 3216-3216 | Added on Friday, 19 January 2024 15:54:06

So how does Trinity recover from this?
- Your Highlight on page 211 | location 3222-3224 | Added on Friday, 19 January 2024 15:54:56

Git is our memory store. We already committed invitation-card.md. This means there is a copy of this file in the index and in the object database. We can ask Git to replace the copy in the working directory with the one in the index.
- Your Highlight on page 211 | location 3229-3230 | Added on Friday, 19 January 2024 15:55:49

Yep. git restore is the opposite of git add. It takes the copy of a file in the index and moves it back into the working directory.
- Your Highlight on page 211 | location 3235-3240 | Added on Friday, 19 January 2024 15:56:35

Trinity has to undo the changes she made to the working directory, by replacing her changes with the ones in the index. She can use the git restore command, supplying it the path to the file that is to be put back. If all goes well, Git will not report anything. The only way to find out is to resort to our good friend, git status. 
- Your Highlight on page 211 | location 3235-3244 | Added on Friday, 19 January 2024 15:56:55

Trinity has to undo the changes she made to the working directory, by replacing her changes with the ones in the index. She can use the git restore command, supplying it the path to the file that is to be put back. If all goes well, Git will not report anything. The only way to find out is to resort to our good friend, git status. The git restore command’s default behavior, as you can see, is the exact opposite of the git add command. The add command takes the version of a file that’s in the working directory and makes a copy of it in the index, overwriting the previous version. The restore command, on the other hand, takes the version of the file stored in the index, and overwrites the version in the working directory. 
- Your Highlight on page 214 | location 3281-3290 | Added on Friday, 19 January 2024 21:51:57

Undoing changes in the index When Trinity fixed her error, she had not yet added the invitation-card.md file to the index. But what if she had? How would she go about restoring her changes? When a file is added to the index, Git makes a copy of the file in the working directory and places it in the index. This is what the state of the working directory would look like for Trinity if she had added invitation-card.md to the index. The answer lies in the output of git status: Git tells us exactly what to do to fix this. We can use the same restore command, except this time we have to give it the --staged flag, followed by the filename, like so: 
- Your Highlight on page 215 | location 3295-3301 | Added on Friday, 19 January 2024 21:56:47

The git restore with the --staged flag is the command you can use to restore files in the index to their previous state. But what does this command actually do? You know git restore (without any flags) replaces the contents of the working directory with the contents held by the index. When the git restore command is supplied with the --staged flag, Git takes the content of the file in the object database, specifically the contents as they were last recorded in a commit, and overwrites the contents of the file in the index with that content. This is what it looks like: 
- Your Highlight on page 216 | location 3301-3305 | Added on Friday, 19 January 2024 21:57:48

Earlier we discussed that git restore is the opposite of git add—the latter copies the contents of a file from the working directory into the index, the former copies from the index into the working directory. You can think of git restore with the --staged flag as having the opposite effect on your files as the git commit command. The git commit command, as you know, takes the contents of the index and stores them in the object database. The git restore command takes the previously committed contents of a file and overwrites the index with them.
- Your Highlight on page 216 | location 3306-3308 | Added on Friday, 19 January 2024 21:58:06

Note: git restore with the --staged flag is not undoing the commit! It’s simply copying the contents of the file as they were last committed into the index.
- Your Highlight on page 219 | location 3358-3361 | Added on Friday, 19 January 2024 22:49:51

And this is the state of Trinity’s repository after she runs this command: Note that the object database is not affected. The question is—what is the status of the repository after we run the git rm command?
- Your Highlight on page 221 | location 3378-3381 | Added on Friday, 19 January 2024 22:52:37

Second, the git rm command only deletes files from the working directory and the index. Versions of the file that were previously committed remain as they were in the object database. This is because a commit represents the changes you made at the time of the commit. If a file existed at the time a commit was made, the commit will remember that for as long as the repository exists.
- Your Highlight on page 221 | location 3386-3392 | Added on Friday, 19 January 2024 22:54:04

Remember that any changes you make, like adding, editing, or deleting files, only affect the working directory. In order to commit the deletion, you also need to remove the file from the index, because a commit only records changes in the index. If you choose to use the Finder (for Mac) or File Explorer (for Windows) to delete a file, you will then have to run the git add command with a special flag, -u or --update, to tell Git to record the name of the deleted file in the index: git add -u gift-registry.md The git rm command, as we have seen, updates the working directory and the index for us, saving us from having to run the git add command again. We feel it’s far more convenient to use the git rm command.
- Your Highlight on page 222 | location 3396-3401 | Added on Friday, 19 January 2024 22:55:39

You mentioned that deleting a file does not remove it from the object database. Is there any way I can delete files from the object database? A: Recall that every commit records everything in the index, along with some metadata (like your name and email address) and the commit message. All this information is used to calculate the commit’s ID. Furthermore, this commit ID may be recorded as the parent of one or more child commits. In other words, removing one or more files from a commit involves recalculating that commit’s ID, as well as those of any child commits. Git does offer some advanced mechanisms to do this, but they fall well outside the scope of this book.
- Your Highlight on page 224 | location 3428-3431 | Added on Saturday, 20 January 2024 00:07:39

As with removing files, you can always choose to rename files using the Finder or File Explorer, but you’ll still have to update the index to reflect the new filenames. However, like the git rm command, the git mv command not only updates the working directory for you, it also updates the index to reflect the change—so you’re just one step away from committing your changes.
- Your Highlight on page 226 | location 3462-3468 | Added on Saturday, 20 January 2024 00:09:48

Be sure to have a clean working directory when amending commits. When amending commits, you should have a clean working directory. Specifically, you want no uncommitted changes in the index, or else the changes you’ve staged will be part of the amended commit! That is, you might accidentally add more changes to the commit than you intended to. Make it a practice to always check the git status prior to amending commits. But what if you have have already staged changes? The easiest thing to do here is to use the git restore command with the --staged flag for every file you have in the index, so that Git puts them back in the working directory. Only then should you amend the latest commit.
- Your Highlight on page 227 | location 3469-3470 | Added on Saturday, 20 January 2024 00:10:05

No. Git only allows you to amend the latest commit on any branch, which we’ve referred to as the “tip” of the branch.
- Your Highlight on page 228 | location 3487-3494 | Added on Saturday, 20 January 2024 00:11:35

When you ask Git to amend a commit, Git pulls a fast one. It essentially looks at the commit you are appending and copies all the changes you made in that commit back into the index. It leaves the original commit as is. It then runs git commit again, this time with the new commit message, which records the changes put in the index by the commit you are amending. You see, Git commits are immutable. That is, once you create a commit, that version of the commit is preserved. Any edits to the commit (like amending it) will create a new commit that replaces the old commit in your history. Think of it as like writing in pen versus pencil: with a pen, you can cross out your mistakes, but you can’t erase them. Immutable commits are one of Git’s biggest strengths, and a lot of the power in Git comes from this simple idea. 
- Your Highlight on page 228 | location 3487-3502 | Added on Saturday, 20 January 2024 00:12:42

When you ask Git to amend a commit, Git pulls a fast one. It essentially looks at the commit you are appending and copies all the changes you made in that commit back into the index. It leaves the original commit as is. It then runs git commit again, this time with the new commit message, which records the changes put in the index by the commit you are amending. You see, Git commits are immutable. That is, once you create a commit, that version of the commit is preserved. Any edits to the commit (like amending it) will create a new commit that replaces the old commit in your history. Think of it as like writing in pen versus pencil: with a pen, you can cross out your mistakes, but you can’t erase them. Immutable commits are one of Git’s biggest strengths, and a lot of the power in Git comes from this simple idea. This is why you should always check the status of your repository before you amend a commit. If by chance you’ve added files to the index and you proceed to amend a commit, all of the files in the index will show up in the new commit. That is, the new commit will record more changes (both the files you had in the index and the files Git added from the amended commit). As for the commit you amend? Git keeps it around for a while, but will eventually delete it from your repository. NOTE This is yet another instance of Git’s cautious nature. By keeping old commits around for a while, it gives you even more chances to recover. How you would go about doing that goes beyond the scope of the book. And don’t worry about those commits lying around—Git is very good at housekeeping.
- Your Highlight on page 230 | location 3515-3530 | Added on Saturday, 20 January 2024 00:14:27

To rename a branch, you use the git branch command—except this time, you supply the -m (or --move) flag. Trinity wants to rename camping-trip to glamping-trip. There are two ways she can go about this. Switch to the branch you wish to fix, then rename: Rename a branch without switching: The second option works regardless of what branch you are currently on—the command works even if the branch you are attempting to rename is the current branch. This is why we always prefer using the second option. NOTE Most Git commands offer different ways of achieving the same thing. Having a consistent way of always doing something frees up your brain so you can think of more important things in life—like, is it a good idea to smear avocado on fruit? What does it mean to put fruit on fruit? NOTE Didn’t realize avocado is a fruit, did ya? See what we mean by more important things in life?
- Your Highlight on page 234 | location 3576-3582 | Added on Saturday, 20 January 2024 09:25:34

Turns out there is! Its name is HEAD. You’ve seen HEAD before. In fact, in Chapter 2 we even gave you a rhyme to help you remember what it means. Here it is again: MAKE IT STICK Violets are blue Roses are red The commit that you’re on Is referred to as HEAD.
- Your Highlight on page 236 | location 3612-3613 | Added on Saturday, 20 January 2024 09:28:51

HEAD: Absolutely! The commit I am pointing to will always be the parent commit of the next commit in the repository. That’s HUGE!
- Your Highlight on page 236 | location 3616-3630 | Added on Saturday, 20 January 2024 09:31:13

The role of HEAD Every time you switch branches, HEAD moves to reflect the branch you switched to. Consider a hypothetical commit history. Let’s say you are on the master branch, so HEAD points to the latest commit on that branch. When you switch branches, HEAD moves to the new branch: HEAD is simply a reference, like branches are. This difference is that a Git repository can have many branches, but there is only one HEAD. HEAD also serves as the launch point to decide how the commit history will change, in that the commit that HEAD points to will be the parent of the next commit—it’s how Git knows where to add the new commit in the commit history. Recall that every time you make a commit on a branch, Git rewrites the branch sticky note to point to the new commit on that branch. Well, there is one more thing that happens—Git moves HEAD to the new commit as well. In Chapter 2, we spoke of merging branches. We referred to the branch you are on as the proposer, and the branch that is being merged in as the proposee. Once you merge the two branches, the proposing branch moves to reflect the merge—in the case of a fast-forward merge, the proposing branch moves to the latest commit on the proposee branch. In the case of a merge that creates a merge commit, again, the proposing branch moves to the merge commit that is created. In both cases, HEAD moves as well.
- Your Highlight on page 239 | location 3650-3652 | Added on Saturday, 20 January 2024 09:32:00

There is a scenario where HEAD points to a commit that isn’t the latest commit on a branch, but some arbitrary commit in your commit graph. This is called a “detached HEAD” state. We’ll revisit this in future chapters. Don’t touch that dial!
- Your Highlight on page 239 | location 3653-3660 | Added on Saturday, 20 January 2024 09:33:38

Given that HEAD points to the commit you are on, you can reference other commits relative to HEAD. Git offers a special operator, the tilde (~), that allows you to do this. Consider this hypothetical commit history: A number n following the tilde operator represents the nth generational ancestor. For example, HEAD~1 references the first parent of the commit you are on. HEAD~2 means the parent of the parent of the commit you are, and so on and so forth. So how does this help you? Suppose you want to find the difference between the commit you are on and the previous commit, using the git diff command. Instead of having to look up commit IDs, here is how you would go about doing it: 
- Your Highlight on page 239 | location 3662-3663 | Added on Saturday, 20 January 2024 09:33:50

HEAD~ is an alias for HEAD~1. We prefer to be explicit, but feel free to use one or the other.
- Your Highlight on page 239 | location 3663-3674 | Added on Saturday, 20 January 2024 09:35:36

Traversing merge commits Merge commits, as we discussed in Chapter 2, are special. They have more than one parent. So how do you go about navigating from HEAD to the first parent? Or the second parent? Recall that the first parent is the latest commit on the proposing branch, and the second commit is the latest commit from the proposee branch. Git offers another operator that works with HEAD: the caret (^), which helps when you’re navigating from commits with multiple parents. Take a look to see how that works for this hypothetical commit graph: Like the tilde operator, the caret operator uses a number to figure out which parent of a merge commit you want to reference. Finally, you can combine the ~ operator and the ^ operator. Here is how HEAD^1~2 would traverse the commit history: SERIOUS CODING You can use the tilde and caret operators with commit IDs as well.
- Your Highlight on page 241 | location 3681-3684 | Added on Saturday, 20 January 2024 09:36:18

What does HEAD~1 mean for a merge commit? A: That’s a great question. As you know, a merge commit has two parents. If you ask Git to look up HEAD~1 for a merge commit, which translates to the merge commit’s parent, Git will follow the path of the first parent. Essentially, HEAD~1 for a merge commit is the same as HEAD^1.
- Your Highlight on page 243 | location 3713-3719 | Added on Saturday, 20 January 2024 10:07:01

In other words, you want to move HEAD to HEAD~1. The command that allows you to do this is the git reset. You can supply git reset with a reference to a commit, either a commit ID or using one of the operators we spoke of, namely tilde (~) or caret (^). The git reset command has two immediate effects—it moves the HEAD and the branch to the commit you specify. But every commit that you make in a repository records a set of changes—you might have added or removed files, or edited existing files, or both. So what happens to those changes? Well, that’s the million-dollar question, isn’t it?
- Your Highlight on page 243 | location 3725-3726 | Added on Saturday, 20 January 2024 10:46:30

Let’s say your repository had two commits—a commit with ID B, and its parent A. 
- Your Highlight on page 243 | location 3725-3731 | Added on Saturday, 20 January 2024 10:48:33

Let’s say your repository had two commits—a commit with ID B, and its parent A. git reset --soft The git reset command can be given the --soft flag. This flag takes the edits you committed and moves them back into the index, and then from the index it copies those changes into the working directory. In other words, the edits you had committed (in commit B) are gone from the object database. It’s like you never made the commit to begin with! But because they are in the index, you’re just one git commit command away from committing them back. Those changes are still available to you—in the index and the working directory. HEAD now points to commit A.
- Your Highlight on page 243 | location 3725-3732 | Added on Saturday, 20 January 2024 10:48:39

Let’s say your repository had two commits—a commit with ID B, and its parent A. git reset --soft The git reset command can be given the --soft flag. This flag takes the edits you committed and moves them back into the index, and then from the index it copies those changes into the working directory. In other words, the edits you had committed (in commit B) are gone from the object database. It’s like you never made the commit to begin with! But because they are in the index, you’re just one git commit command away from committing them back. Those changes are still available to you—in the index and the working directory. HEAD now points to commit A. 
- Your Highlight on page 244 | location 3739-3752 | Added on Saturday, 20 January 2024 10:51:47

Using git reset (or git reset --mixed) The git reset command’s default mode is --mixed, so you can invoke git reset or git reset --mixed with the same results. This is how to use it: git reset A     OR     git reset --mixed A The --mixed mode does a bit more work than the --soft mode does. It has two steps: First, it moves the changes in commit B (the commit you are undoing) into the index, and then copies those changes from the index into the working directory, just like --soft mode does. It then copies the contents of commit A into the index. That is, the index now looks exactly like the commit you just reset to. Contrasting the soft and mixed behavior: --soft mode leaves both the index and the working directory changed. But --mixed mode only leaves the working directory changed. With mixed mode, the changes you committed in “B” reside only in the working directory—the index looks like the changes in commit “A.”.
- Your Highlight on page 246 | location 3758-3768 | Added on Saturday, 20 January 2024 10:53:49

git reset --hard Finally, the third flag that reset offers is --hard. Remember, the intent is to undo the changes in a commit. --soft mode moves the changes in the commit you are undoing and puts them in both the index and the working directory. --mixed mode on the other hand puts the changes in the commit you are undoing (“B”) into the working directory, but the index and the object database look like the commit you reset to (“A”). Effectively, --mixed mode takes the changes you had in the commit that you just undid, and makes them appear in the working directory. Finally, the --hard mode takes what the --mixed mode does to its logical end. In mixed mode, the second step copies the contents commited in “A” into the index, and stops there. --hard mode does not. It takes the contents of the index (which have the changes as they are in commit A) and overwrites the working directory. This means that the object database, the index, and the working directory all look the same. It’s as if commit B never happened! After a hard reset, the working directory, the index, and HEAD all look like commit “A.” 
- Your Highlight on page 247 | location 3774-3778 | Added on Saturday, 20 January 2024 10:55:03

You mentioned that the reset command can take a commit reference. So can I reset to any commit, instead of just the parent commit? A: Yes, you can. For example, if you invoke git reset HEAD~3, you are asking that Git take you back three commits. Git will then collect the changes you made in all three commits (that you are undoing), and depending on the mode you specify (--soft, --mixed, or --reset), Git will place those changes in the index, working directory, or throw them away. But baby steps, right? Let’s take it one step at a time.
- Your Highlight on page 247 | location 3779-3788 | Added on Saturday, 20 January 2024 10:57:02

Q: How is using git reset --mixed different than git restore with the --staged flag? They both copy the content of the object database into the index, right? A: First, the git restore command works at the file level, that is, it only works with one file at a time. The git reset command works at the commit level, effectively undoing all the changes committed. This might be more than one file that you potentially added, edited, or modified in the commit you are undoing. Second, the git restore command with the --staged flag takes the contents of the file you specify as they were last committed, and copies that into the index, effectively making the file in the index look exactly like it did since you last committed. It does not, however, move the HEAD—the git restore command does not modify your commit history. In contrast, while git reset --mixed does copy all of the files as they were last committed and move them into the index, it also moves the HEAD to the commit you specify. When you use the git reset command, you’re rewriting history by erasing history!
- Your Highlight on page 248 | location 3789-3792 | Added on Saturday, 20 January 2024 10:57:20

Q: Can I reset a merge commit? A: Yes, you can. But remember, a merge commit has two parents. And the git reset command needs to know which commit to reset HEAD and the corresponding branch to. So, if you are going to reset a merge commit to one of its parents, you will need to supply which parent you wish to reset to using the caret (^) operator.
- Your Highlight on page 250 | location 3825-3836 | Added on Saturday, 20 January 2024 11:00:03

Trinity has two options. The first approach is using the git reset command. However, Git offers us another approach, but before we get to that, let’s take a minute to talk about what a commit is. A commit records a set of changes—you might have edited a bunch of files, maybe added or deleted a few. You’ll see these changes if you use the git diff command to compare a commit with, say, its parent. They appear as a set of pluses (“+”) and minuses (“-”). This is referred to as the “delta,” or the variation between two commits. Another approach to undoing a commit is as simple as negating a commit—for every file added, you could delete it, and vice versa. For every line in every file that was added, you delete it, and for every line that was deleted, bring it back. Given that Git can calculate the differences introduced by a commit, it can also calculate the reverse of the differences, or if you like, the “anti-commit.” And you can use this to “undo” a commit. NOTE If it helps, think of matter and anti-matter coming in contact with each other. End result: complete annihilation!
- Your Highlight on page 251 | location 3836-3847 | Added on Saturday, 20 January 2024 11:01:31

Reverting commits You can create “anti-commits” by using the git revert command. The revert command, like the reset command, can be given a commit ID or a reference to a commit. There is a big difference, though—the git revert command is to be given the ID or reference of the commit you want to undo. Consider our hypothetical repository again—let’s say you want to undo commit B. This is how you would use the git revert command: Git looks at the changes introduced in B and calculates the anti-commit. This is an actual commit that Git will prepare. Now just like any other commit, this commit needs a commit message. So Git will use your preconfigured editor and bring it up, prompting you to supply a message for the newly created commit: NOTE We have seen this before, in Chapter 2: when we merge two branches, that results in an merge commit. Recall that Git brings up your editor and prompts you for a commit message.
- Your Highlight on page 251 | location 3836-3853 | Added on Saturday, 20 January 2024 11:02:05

Reverting commits You can create “anti-commits” by using the git revert command. The revert command, like the reset command, can be given a commit ID or a reference to a commit. There is a big difference, though—the git revert command is to be given the ID or reference of the commit you want to undo. Consider our hypothetical repository again—let’s say you want to undo commit B. This is how you would use the git revert command: Git looks at the changes introduced in B and calculates the anti-commit. This is an actual commit that Git will prepare. Now just like any other commit, this commit needs a commit message. So Git will use your preconfigured editor and bring it up, prompting you to supply a message for the newly created commit: NOTE We have seen this before, in Chapter 2: when we merge two branches, that results in an merge commit. Recall that Git brings up your editor and prompts you for a commit message. We usually prefer to keep the message as is. Once you close the editor, Git will confirm creating a new commit. So what is the effect of a revert? This is what your commit history will look like after a revert: Like the git reset command, the git revert command moves the HEAD and the branch, except in this case, you are not erasing commits. Rather, you are adding new commits. However, both commands allow you to “undo” commits.
- Your Highlight on page 257 | location 3932-3934 | Added on Saturday, 20 January 2024 11:05:42

You are still required to make a commit to record the fact that you deleted one or more files. That is, removing files is a two-step process—git rm removes the files from the working directory and the index, and the subsequent commit records the deletion.
- Your Highlight on page 257 | location 3936-3939 | Added on Saturday, 20 January 2024 11:06:42

You should only amend the tips of branches. When you amend a commit, you are not actually changing a commit. Git records a new commit with the new commit message and replaces the previous commit in your commit history. Git will eventually delete the older commit.
- Your Highlight on page 280 | location 4286-4290 | Added on Saturday, 20 January 2024 11:18:11

So what just happened? The repository we created is under our account, which means that while you can see it, you can’t modify it. Forking is a GitHub feature that makes it easy to copy our repository (or any other publicly available repository) to your account. NOTE Not to beat a dead horse, but there is no such feature as “forking” in Git itself. Forking is a feature GitHub offers to make it easier to collaborate.
- Your Highlight on page 281 | location 4305-4311 | Added on Saturday, 20 January 2024 14:49:13

Can I clone a repository without forking? If so, what does that mean? A: Absolutely. You could visit github.com right now, peruse any one of the millions of repositories available, and clone any one of them. However, if you wanted to collaborate on that project, you’d have to ask the owner of that repository for permissions. Throughout this chapter you are going to be making changes to the working-with-remotes repository. By forking it, you get a copy of our repository under your account in GitHub, and you can do with that whatever you like without us granting any additional permissions. Certainly makes things easier all around.
- Your Highlight on page 285 | location 4360-4365 | Added on Saturday, 20 January 2024 14:53:30

Q: You made us fork the repository first, then clone it. Is this a usual workflow? A: That depends. For a project at work, you will most likely be made a collaborator on that project, which automatically gives you permissions to modify the repository. This means you wouldn’t have to fork the repository—you could simply clone it and start collaborating with your colleagues. However, if you want to play around with or contribute to an open source project, you’ll most likely need to fork the project. This makes it easier for the people managing the open source project, because they don’t have to explicitly add you as a collaborator.
- Your Highlight on page 286 | location 4384-4402 | Added on Saturday, 20 January 2024 14:56:17

What happens when you clone? If you wish to clone a repository, your starting point is always another repository, which is referred to as the remote. And much like any repository you’ve worked with so far, the repository you clone consists of commits, branches, HEAD, commit history, and anything else a repository can have in it. When you clone such a repository, Git does a few things: Git first creates a folder in the directory where you ran the git clone command; the folder will have the same name as the repository you are cloning (unless you specify a different name). Inside that, it creates a .git folder. It then copies the entire commit graph, including all commits, branches, and a few other things, from the repository you are cloning into the .git folder it just created. Finally, it uses the git switch branch to check out the same branch that was checked out in the original (the one you are cloning from). NOTE This would be the same commit as HEAD points to. NOTE You know from Chapter 2 that when Git switches branches, it rewrites the working directory to look exactly like it did when you made the last commit on that branch. 
- Your Highlight on page 314 | location 4814-4817 | Added on Saturday, 20 January 2024 21:20:23

The terms upstream and downstream, while commonly used, are a bit confusing when you’re working with a distributed system like Git. When we clone a repository and it gets data and puts it onto our local machine, the local is downstream. When we push, or send data from the local to the remote, the remote is upstream from us. And yes, in our case, setting upstream is the same as setting the remote.
- Your Highlight on page 323 | location 4942-4945 | Added on Saturday, 20 January 2024 21:28:50

GitHub’s default behavior is to always create a merge commit. GitHub uses a special flag when merging that forces Git to create a merge commit. GitHub does offer other ways to merge branches that don’t create a merge commit, but that’s a conversation for another time. For now, just remember that using the defaults in GitHub will create a merge commit.
- Your Highlight on page 358 | location 5476-5483 | Added on Sunday, 21 January 2024 15:14:17

These branches that Git creates when you clone (prefixed with the name of the remote) are called remote tracking branches. Git hints at their presence in the output of many commands—you’ve probably seen references to remote tracking branches when you check the status of your repository. For example: Remote tracking branches are different from the branches that you’ve worked with so far—you can’t switch to them, you can’t create or delete them. In fact, you have no control over these branches. They are meant to be managed by Git. On the prevous page, we listed several of the roles these remote tracking branches play. Now let’s dive into the details. NOTE This is an important point!
- Your Highlight on page 360 | location 5517-5519 | Added on Sunday, 21 January 2024 15:18:22

As you can see, as soon as you push, your local branch, its counterpart in the remote, and the newly created remote tracking branch (origin/feat-a, in this case) all point to the same commit ID. Recall that once you set the upstream for a branch, you never have to do it again—and now you know the reason. Git records where to push a branch with the help of the remote tracking branch.
- Your Highlight on page 367 | location 5621-5632 | Added on Sunday, 21 January 2024 15:24:27

 clone   Displays details about the remote   remote   Shows a list of all your branches.   branch   Lists all branches along with their remote tracking branches (if any)   push   Is another way to initialize a Git repository   branch -vv   Updates the remote branch with any new commits you made locally 
- Your Highlight on page 369 | location 5647-5652 | Added on Sunday, 21 January 2024 21:41:30

You already know how to push a local branch to the remote. But how does another collaborator get that branch? The answer lies in another Git command, called fetch. The role of the git fetch command is to download all new commits and branches from the remote. But it does so with a twist! The git fetch command updates your clone without affecting any of your local branches. How, you ask? It updates the remote tracking branches. Consider a hypothetical repository where you only have one branch, called master. You just invoked the git pull command, so your clone is caught up with the remote. 
- Your Highlight on page 369 | location 5654-5655 | Added on Sunday, 21 January 2024 21:41:56

pull—fetch only updates the remote tracking branches, whereas pull, as you know, updates both the remote tracking branch and your local branch.
- Your Highlight on page 378 | location 5787 | Added on Sunday, 21 January 2024 21:50:42


- Your Highlight on page 381 | location 5831-5849 | Added on Sunday, 21 January 2024 21:56:39

Reason 4 for remote tracking branches: getting ready to push Remote tracking branches can tell you where your branch is in relation to the remote tracking branch. However, remember, remote tracking branches don’t update themselves. They wait for you to run the git fetch command. What does that mean? Let’s go back to a hypothetical repository where you have a master branch in the remote and in your clone, and you are merrily working away. There is a chance that, in the meantime, your fellow collaborator pushed a new commit on the master branch to the remote! Let’s take a look. Your clone is unaware of the new commit, since you haven’t fetched yet! This presents a conundrum. Precisely! As you can see, your master branch and its counterpart in the remote have diverged. Commit B’s child in the remote is commit D, while in your clone, commit B’s child is C. It’s not uncommon to see the remote counterpart of a branch diverge away from your local branch—especially when two or more collaborators are working together on the same branch and pushing to the remote. Suppose your local branch (say it’s master) has indeed diverged from its counterpart in the remote. What happens when you push? NOTE We’ll show you some best practices in a few. Git rejected your attempt to push. The reason is simple: Git sees new commits on the master branch in the remote and the master branch in your clone and cannot reconcile them automatically. So what do you do now? Well, this is where remote tracking branches really shine. The name—remote tracking branches—has two distinct parts: So how does any of this help with our current conundrum? Look to the next page.
- Your Highlight on page 382 | location 5849-5879 | Added on Sunday, 21 January 2024 21:59:53

Reason 4 (still going) So far, you’ve discovered that remote tracking branches inform you that you might want to push commits (Reason 3), but they don’t seem to be of much help in letting you push—particularly if your local branch has diverged from its remote counterpart. Or are they? What happens if you invoke the git fetch command in that scenario? Let’s take a look: Remember, the git fetch command updates all remote tracking branches to look like their remote counterparts. In this scenario, the remote tracking branch origin/master now points to commit D (since that’s what the remote master branch is pointing to). If you want to push your changes (and you know Git won’t let you), you’ll need to help Git reconcile the difference between origin/master (which is what the remote master branch has, since you just fetched) and your local master branch. Let’s see how to do that next! BRAIN POWER Take a long, hard look at the commit history for the clone shown above. If you were to merge origin/master into the master branch, would that be a fast-forward merge, or would it create a merge commit? Hint: Have the two branches diverged? Reason 4 (Yep! Almost there!) You now know that remote tracking branches are, in fact, branches. Which means you can merge origin/master into your local master branch. Here’s what that would look like: Merging origin/master into your local master is just the same as any other merge. Recall from Chapter 2 that if the two branches have diverged, then Git will attempt to create a child commit and present you with your configured editor to type in a commit message. If the branches haven’t diverged, then it’ll be a fast-forward merge. After merging origin/master into your local master, your local master branch has both—the changes introduced in the remote master and your changes—which means you’ve reconciled the differences between the two branches. You can now attempt to push! NOTE You can’t merge into the remote tracking branch because you can’t switch to it. WATCH IT! You can get merge conflicts! When you merge changes that appear on the remote tracking branches into your local branches, there is a possibility that you will get one or more merge conflicts. Just remember—merging remote tracking branches into local branches is no different than any other merge.
- Your Highlight on page 385 | location 5897-5901 | Added on Sunday, 21 January 2024 22:05:13

You aren’t wrong! That’s exactly right, in fact. Fetching gets you anything new in the remote, and merging the remote tracking branch into the local branch means your local is now “caught up” with its remote tracking branch. Which is exactly what git pull’s job is. And that is the secret we are going to share with you on the next page. But if you are looking for the teaser trailer, here it is—git pull is the same as doing a git fetch followed by a git merge!
- Your Highlight on page 386 | location 5917-5922 | Added on Sunday, 21 January 2024 22:06:18

Use git fetch + git merge. Avoid git pull. We don’t like surprises (we don’t even do well even at our own birthday parties). Our take on this: git pull, though convenient, is too magical. Personally, we prefer to use git fetch followed by git merge to “catch up with the remote.” And we have good reasons for this! NOTE If you are wondering why we brought up git pull, well, you’ll see it being referenced in many a tutorial and blog post. We just want you to know what it does.
- Your Highlight on page 391 | location 5984-5997 | Added on Sunday, 21 January 2024 22:10:47

In Scenario 1, you’ve added one or more commits to the master branch. But when you fetched, the remote had no new commits, so origin/master did not move. In Scenario 2, you’ve made no changes to your local master branch. However, when you fetched, you got some new commits on your remote tracking branch. In both cases, you can see that the remote tracking branch and its local counterpart have not diverged. Which means when you merge the remote tracking branch into the local branch, you will get a fast-forward merge. This is exactly what happened when we showed you the git pull command at the beginning of the chapter. Here is the console output from early on in this chapter: This is because git pull performs a merge under the covers. Even if you had fetched and merged origin/master into master, you would have gotten the same result. And a fast-forward merge is exactly what you want! So how do you get there? How can you make it so that when you do catch up with the remote, it’s always a fast-forward merge? NOTE We mentioned this in Chapter 2 as well—when merging, fast-forward is the best-case scenario.
- Your Highlight on page 392 | location 5997-6018 | Added on Sunday, 21 January 2024 22:12:33

A typical workflow: getting started Here’s a summary of what you’ve learned so far. Things get complicated when your local branch diverges from its counterpart in the remote. Why? Because when you do attempt to catch up, it will result in a merge, and potentially merge conflicts. So can you avoid the merge? What if you try to make it so that the remote only sees commits that you push to it? In other words, no one else should be pushing to that branch. And how do you do that? Well, ideally, every contributor should work on their own feature branches. This way, no one execpt you pushes to your remote branch. Problem solved! NOTE If you were thinking this is Scenario 1 from the previous page, you are absolutely correct. Only your local branch introduces new commits. Let’s see what this looks like. You are assigned a new task, so you start by making sure that the integration branch (say, master) in your clone is “caught up” with the remote. NOTE This is important! You always want to try and create new feature branches from the latest commits on integration branches. NOTE Remember, catching up involves fetching, then merging origin/master into master. You then follow the same workflow we described in Chapter 2. Create a new branch based on the integration branch, make your commits, and when you think you are in a good place, push. The important takeaway here is that this feature branch is yours and yours alone. No one else is pushing to this branch, which means you’ll never see a merge (and potentially a corresponding merge conflict) between your local branch and the remote tracking branch. NOTE It’s a good habit to keep pushing your work to the remote, even if you aren’t done yet. This way there is a copy of your work on the remote in case something happens to your workstation. And now you are ready to merge.
- Your Highlight on page 394 | location 6030-6048 | Added on Sunday, 21 January 2024 22:15:13

A typical workflow: getting ready to merge The majority of your workflow will consist of working on your local feature branch (and occasionally pushing). But eventually, you’ll want to get your code into an integration branch (for the sake of this example, we’ll call it master). So what does that look like? You’ve seen that you need to be sure that when you create a feature branch, you are always basing it on the latest commits on the master branch at that time. However, the role of the integration branch is to incorporate everyone’s work! Which means that while you were busy chugging away, your collaborators might have merged their work into master. Before you merge, it’s a good idea to know if your work will play well with theirs. How do you do that? Just before you merge your work, merge the work on master into your feature branch. Effectively, your feature branch is now caught up with the integration branch. There are two ways to go about doing this: Do a git fetch and merge origin/master into master. Then merge master into your feature branch. Do a git fetch, then merge origin/master into your feature branch. NOTE We alluded to this in the last “No dumb questions” segment. NOTE In case you are wondering, this is the first time in this book that we’ve merged the integration branch into a feature branch. Always a first time for everything, huh?
- Your Highlight on page 394 | location 6030-6056 | Added on Sunday, 21 January 2024 22:16:18

A typical workflow: getting ready to merge The majority of your workflow will consist of working on your local feature branch (and occasionally pushing). But eventually, you’ll want to get your code into an integration branch (for the sake of this example, we’ll call it master). So what does that look like? You’ve seen that you need to be sure that when you create a feature branch, you are always basing it on the latest commits on the master branch at that time. However, the role of the integration branch is to incorporate everyone’s work! Which means that while you were busy chugging away, your collaborators might have merged their work into master. Before you merge, it’s a good idea to know if your work will play well with theirs. How do you do that? Just before you merge your work, merge the work on master into your feature branch. Effectively, your feature branch is now caught up with the integration branch. There are two ways to go about doing this: Do a git fetch and merge origin/master into master. Then merge master into your feature branch. Do a git fetch, then merge origin/master into your feature branch. NOTE We alluded to this in the last “No dumb questions” segment. NOTE In case you are wondering, this is the first time in this book that we’ve merged the integration branch into a feature branch. Always a first time for everything, huh? Whichever option you pick, the end result will be the same. Your feature branch now contains all your new work and the work your contributors put into the integration branch. You can now do some spot checks or run tests to make sure it all works well together. Now you are ready to merge! WATCH IT! Obligatory merge conflict warning NOTE Our lawyers made us put this here. This workflow involves a merge, which can always lead to a merge conflict. Be advised!
- Your Highlight on page 395 | location 6056-6068 | Added on Sunday, 21 January 2024 22:17:27

A typical workflow: merge locally, or issue pull requests? You know that you have two options to merge your work into the integration branch: you either merge locally into the integration branch, or push your branch upstream and issue a pull request. We spoke of the differences between the two at the end of Chapter 5: merging locally means that you are adding commits to the integration branch locally (which you’ll have to push upstream after the merge). The second option means that you will merge using your Git repository manager (like GitHub)—that is, the merge happens in the remote. We prefer using pull requests to merge our code into the integration branch for one simple reason: we want to avoid adding commits to integration branches in our clone. Remember, it’s not just you working on a shared repository. Your colleagues are working on it as well. Suppose you do merge into the integration branch locally—another contributor could be doing the same thing at the same time in their clone. If they beat you to the punch and push the integration branch to the remote, what happens when you attempt to push? Git will reject your push, because the remote branch has now diverged from your local copy. This is exactly the problem we’ve been trying to avoid! With pull requests, you are merging in the remote, of which there is only one. This means you are not updating the integration branch locally anymore.
- Your Highlight on page 396 | location 6072-6081 | Added on Sunday, 21 January 2024 22:18:30

Q: Wait. We merge the integration branch into my feature branch, and then merge the feature branch back into the integration branch? Seems like a lot of merging is going on. Why not just merge my feature branch into the integration branch directly? A: The objective here is to get your work into the integration branch. However, it’s a good idea to check that everything will be well after the merge. When you merge the integration branch into your feature branch, you are essentially “catching up” with the integration branch. You can resolve any conflicts and check to make sure all is well. If something does not seem right, you can still create additional commits in your feature branch to fix those issues. The second merge, which involves merging your feature branch into the integration branch, gets you where you want to be—your work is now integrated. A typical workflow visualized 
- Your Highlight on page 399 | location 6108-6115 | Added on Sunday, 21 January 2024 22:21:09

Recall that when you push a branch for the first time, you have to set the upstream (using either the --set-upstream or -u flags). When you do, Git creates the branch in the remote, then creates the remote tracking branch in your clone. Similarly, when you push a deletion, Git will first delete the branch in the remote, and then clean up the remote tracking branch in your clone. Doesn’t seem that counterintuitive anymore, does it? If you follow our recommended approach of using pull requests, delete the branch using the “Delete branch” button in GitHub after your pull request is merged in. This takes care of the branch in the remote. But it still leaves the remote tracking branch and the local branch. Solution? Next page.
- Your Highlight on page 399 | location 6108-6122 | Added on Sunday, 21 January 2024 22:21:30

Recall that when you push a branch for the first time, you have to set the upstream (using either the --set-upstream or -u flags). When you do, Git creates the branch in the remote, then creates the remote tracking branch in your clone. Similarly, when you push a deletion, Git will first delete the branch in the remote, and then clean up the remote tracking branch in your clone. Doesn’t seem that counterintuitive anymore, does it? If you follow our recommended approach of using pull requests, delete the branch using the “Delete branch” button in GitHub after your pull request is merged in. This takes care of the branch in the remote. But it still leaves the remote tracking branch and the local branch. Solution? Next page. WATCH IT! Git errors out when you push a deletion If Git reports an error like error: failed to push some refs, that means that a branch with that name does not exist in the remote. Check the name of the origin and the branch you supplied to git push -d. You can always check GitHub and see if you see that branch in the branch drop-down menu. It might have already been deleted.
- Your Highlight on page 400 | location 6122-6127 | Added on Sunday, 21 January 2024 22:22:39

Remote tracking branches are managed by Git, so it’s best to have Git delete them when they no longer have a remote counterpart. Remote tracking branches show up in the clone for two different reasons: you created a local branch and pushed it upstream, or a fellow collaborator created a branch, pushed upstream, and you did a fetch. The easiest way to clean up all remote tracking branches that no longer have a remote counterpart is use the -p (or --prune) flag that the fetch command supports. With this option, you get all the new branches and commits that show up in the remote but also clean up any remote tracking branches that no longer have a remote counterpart! A twofer? Yes, ma’am!
- Your Highlight on page 402 | location 6159-6161 | Added on Sunday, 21 January 2024 22:23:46

We know we’ve been telling you to get in the habit of fetching often. The real advice here is to get in the habit of using git fetch -p (or --prune) often. This ensures that your list of remote tracking branches always reflects what’s available in the remote. This way you know which local branches you should delete locally.
- Your Highlight on page 432 | location 6623-6627 | Added on Monday, 22 January 2024 22:48:40

Seeing who changed what and when with git blame Every commit you make introduces “diffs”—files that were added or removed or edits to existing files, like adding or removing content—from the previous change. And Git is absolutely brilliant at tracking those changes: it can tell you exactly when a line was changed, who changed it, and the ID of the commit that introduced that change. To see this, use the git blame command: 
- Your Highlight on page 433 | location 6639-6640 | Added on Monday, 22 January 2024 22:52:08

Furthermore, since git blame only looks at the lines in the file at the time you run it, it cannot tell you about deleted lines.
- Your Highlight on page 434 | location 6651-6654 | Added on Monday, 22 January 2024 22:55:15

This means that we can ask git blame to show us the revision history of a file at any commit, simply by giving it the commit ID and the filename! Suppose one of the commits you see in the git blame output happens to be c3668177. You can supply that ID to git blame, and it will show you the revision history of the file as it looked at the moment the commit was made. 
- Your Highlight on page 437 | location 6695-6702 | Added on Monday, 22 January 2024 23:01:14

Let’s say you want to find all the places where you used Aref’s name. You can grep for it (using git grep Aref), and this is what Git will present you: There are a couple of things to note about git grep’s output. First, Git will list out every instance that contains the string you are searching for, which means you might see the same filename listed multiple times (if the word you are looking for happens to be in a file more than once). Git also lists files in alphabetical order, making it easier to scan if you are looking for a particular file. NOTE Uppercase letters appear before lowercase letters.
- Your Highlight on page 439 | location 6728-6735 | Added on Monday, 22 January 2024 23:07:52

The git grep command’s functionality is very specific—by default, it only searches files that Git knows about. That is, git grep only searches files that Git is tracking. This means that if you have files in your repository that you haven’t added to the index yet, git grep will not search those! Also, there is a way to tell Git to ignore some files in a directory (more about this in the next chapter). Git’s grep command will also ignore these files. This is both a boon and a curse: it’s great if you don’t want to search these files because they aren’t technically part of your repository, but it works against you if you do want to search them for a particular use case. For the latter scenario, you might be better off using your editor’s search facilities or tools like Bash’s grep command.
- Your Highlight on page 441 | location 6748-6753 | Added on Monday, 22 January 2024 23:10:27

Q: I am familiar with Bash’s grep command. Why would I prefer one over the other? A: Git’s grep, by default, does not search your files. Rather, it searches its index and database, so it can make good use of Git’s efficient internal storage. This means that Git’s grep can be a lot faster than Bash grep. On the other hand, if you wish to search all files in a project, including tracked and untracked files, Bash’s grep is your friend. However, it’s not an either/or—depending on the use case, we’ve found that we reach for one or the other.
- Your Highlight on page 442 | location 6770-6771 | Added on Monday, 22 January 2024 23:42:38

However, Git blame works at a line level! Git blame can tell you when a particular line was last changed, but it can’t tell you what changed in that line when that commit was made. And finally, git blame only looks at one file at a time.
- Your Highlight on page 443 | location 6782-6786 | Added on Monday, 22 January 2024 23:44:19

Well, Git knows the commits you’ve made, and you know that a commit records the state of the files as they were in the index at that time. Which means Git should be able to compare every commit with its predecessor and see if a particular piece of text was added or deleted. git log’s “pickaxe” capability (-S) NOTE It’s not as scary as it sounds. We pinky promise.
- Your Highlight on page 443 | location 6788-6797 | Added on Monday, 22 January 2024 23:46:28

If you ever wanted to know when a particular piece of text was added or removed, you need look no further than our good friend and ally, the git log command. It offers several options to search the “diff” that each commit introduces—that is, git log can help you search the changes introduced by each commit. Consider the first two commits we showed you on the previous page: If you are interested in when the word “tired” first appeared or disappeared, you can use the git log command with the -S (uppercase “S”) flag. This lets you search the diffs of each commit like so: NOTE The search capabilities offered by git log are referred to as the “pickaxe” options. -S is one way to do this. We’ll show you another search option soon. And this is what Git will show you: 
- Your Highlight on page 444 | location 6798-6804 | Added on Monday, 22 January 2024 23:47:09

git log -S versus blame There are a couple of differences between the git log’s search results and those of git blame. First, the pickaxe option (-S) is not restricted to a single file. In our example, using the pickaxe option to search for “tired” searches your entire repository—it’s not limited to a single file. You can restrict git log to only display the log for a single file by supplying the filename at the end. Think about it this way—git blame is a way to attribute changes in a single file, while git log’s pickaxe option is a search mechanism for your entire repository.
- Your Highlight on page 445 | location 6822-6839 | Added on Monday, 22 January 2024 23:51:00

Using the “patch” flag with git log If you ever wanted to see the actual diff that each commit introduced, you can use yet another flag with git log, which is -p (shorthand for --patch). This is true for every instance of git log that we’ve shown you in this book. For example, you could combine the -p flag with our favorite combo of git log flags like so: With the “patch” flag, Git will display your commit graph just as you are used to seeing it, along with the differences introduced in each commit: Back to searching—combine the pickaxe flag (-S) with the -p (--patch) flag, and git log will show you every commit that has the search string in its diff, as well as the diff itself! So does this get us closer to knowing when the word “tired” appeared or was deleted? Let’s find out. If you provide the patch (-p) flag along with the search term (-S), here is what Git has to offer: Recall that the git log command displays commits in reverse chronological order, so the commit that introduced the word “tired” is at the bottom of the output, preceded by the commit that changed “tired” to “lazy.” And one last piece that’ll make your life easier—like the diff command, the log command also supports the --word-diff flag when displaying patches! So if the above is too verbose for you and you like your output to be as succinct as you can make it, here is
- Your Highlight on page 448 | location 6856-6870 | Added on Tuesday, 23 January 2024 09:26:21

git log’s other “pickaxe” flag (-G) Git log’s -S flag can help you find every commit where the text you are looking for was either added or deleted, which is super handy. But what if you want to find every time a particular piece of text showed up in the diff of a commit? Let’s go back to our single-line-file example and take a look at the diffs of the last two commits—keep an eye out for the word “lazy”: The -S flag in this case will only list commit 2 because it only lists commits where the text you are searching for (“lazy” in this case) was either added or deleted. The -S flag will not list commit 3 because it does not affect the number of times lazy appears—rather, commit 3 affects the line that contains the word “lazy.” Why would you ever perform a search like this? Maybe someone introduced a typo somewhere on the line that contains the word “lazy”—searching for “lazy” will highlight anytime that line was changed in some way. Or if you want to see how the arguments of a function have changed over time—you could just search for the name of the function. As we discussed, git log’s -S flag will not do the trick for this. Rather, you want to use the -G option. You use it just like the -S option, and it will highlight every commit whose diff includes the word you are looking for. Everything that we’ve talked about with the -S flag applies to the -G flag—you can display the individual patches for each commit listed with the -p (or --patch) flag, and you can use --word-diff and --oneline flags as well.
- Your Highlight on page 450 | location 6898-6901 | Added on Tuesday, 23 January 2024 09:28:51

Suppose you wanted to find every commit that uses the phrase “first draft” in its commit message: You can combine --grep with other flags like --graph and --oneline.
- Your Highlight on page 451 | location 6912 | Added on Tuesday, 23 January 2024 09:29:27


- Your Highlight on page 453 | location 6945-6947 | Added on Tuesday, 23 January 2024 09:32:28

We know what it means to check out a commit. So how do we go about checking out a particular commit? 
- Your Highlight on page 454 | location 6948 | Added on Tuesday, 23 January 2024 09:33:14


- Your Highlight on page 454 | location 6955-6963 | Added on Tuesday, 23 January 2024 09:34:53

Detached HEAD state When you check out a commit using its ID, Git says You are in 'detached HEAD' state. What this means is that you are no longer on a branch. And why does that matter? There are two things to keep in mind: The commit that HEAD points to will be the parent of the next commit. There is nothing stopping you from making edits to your repository and making a commit at this point! What would your history look like if you did make a commit? Here’s what your commit history would look like: 
- Your Highlight on page 454 | location 6955-6966 | Added on Tuesday, 23 January 2024 09:36:12

Detached HEAD state When you check out a commit using its ID, Git says You are in 'detached HEAD' state. What this means is that you are no longer on a branch. And why does that matter? There are two things to keep in mind: The commit that HEAD points to will be the parent of the next commit. There is nothing stopping you from making edits to your repository and making a commit at this point! What would your history look like if you did make a commit? Here’s what your commit history would look like: As you can see, you’ve now created a new timeline, except there is no branch reference. While that might seem innocuous, what would happen if you then decided to switch back to the master branch? HEAD would move to the commit that the master branch points to—leaving your new commit behind. Whoops! 
- Your Highlight on page 455 | location 6973-6977 | Added on Tuesday, 23 January 2024 09:37:09

The lesson here? If you ever want to see what your repository looked like at a particular point in time, use Git’s checkout facilities to do just that. However, be sure to create a branch first and switch to it before making any edits when you are in detached HEAD state! Remember, branches are cheap. If you decide later on that you don’t care to keep those changes around, simply delete the branch. This way, your work resides safely on a branch, and you can always switch back to it if you like, without running the risk of losing your changes. Win-win!
- Your Highlight on page 459 | location 7025-7027 | Added on Tuesday, 23 January 2024 09:39:33

But let me show you another way to find out which commit introduced a particular change. It’s called git bisect. It helps you search all your commits using an efficient search algorithm called binary search.
- Your Highlight on page 459 | location 7027-7036 | Added on Tuesday, 23 January 2024 09:40:14

Let’s say you have five commits in your repository. You know you have a typo in the latest commit, but it wasn’t there in the first commit. Now suppose I show you the state of the repository as it looked in commit 3, and after looking around you conclude the typo isn’t there. That is, commit 3 is “good.” What would that tell you? Armstrong: That means the typo appeared in commit 4 or 5! Trinity: Right! And what if commit 3 is “bad,” as in, the typo was there? Armstrong: We know it wasn’t in commit 1, so it has to be in 2 or 3 itself. Trinity: Yep. You just did a binary search of commits—you pick two commits and find one somewhere in between—say, commit 3. If the typo isn’t there, that means it’s either in commit 4 or 5. Otherwise you go further back, eventually zeroing in on the right commit. Armstrong: And Git can help you with this? That’s awesome!
- Your Highlight on page 461 | location 7057-7061 | Added on Tuesday, 23 January 2024 10:36:29

Searching for commits using git bisect Git log’s pickaxe options (-S and -G) are incredibly powerful. However, they fall short when you don’t know exactly what to search for. Consider a scenario where you’ve found a bug in the master branch. You don’t know what’s causing it, so you don’t know what to search for—which means the pickaxe options are no help.
- Your Highlight on page 462 | location 7074-7099 | Added on Tuesday, 23 January 2024 10:41:21

Using git bisect Let’s walk through a git bisect session together. We’ll use a hypothetical repository that has five commits. We just noticed that the latest commit has a bug in it. Let’s go ahead and assume that the first commit is good. To start bisecting commits, we have to first tell Git to kick off a bisecting session. Next you have to tell Git the “bad” commit ID—in this scenario, HEAD has the bug, so let’s tell Git that. Then you tell Git the “good” commit ID, which in this case is commit ID By telling Git where the “bad” and “good” commits are, you are giving Git a range of commits to search. Git immediately gets to work—starting a binary search. It finds a commit somewhere halfway between the “bad” and “good” commits, and uses the git checkout command to check out that commit. You are in business! Now go find that pesky commit, will ya? The git bisect session is all set up, and Git has already checked out a commit for you. Git status confirms this: Where do things stand? Recall that checking out a commit means Git has replaced all the files in your working directory to look like they did when you made that commit: At this point, you can look at the files in your project in your editor and see if you spot the bug. Or you could run the application, run your tests, what have you. You’ll probably draw one of two conclusions—the bug is in this commit, or the bug is not in this commit. If you do see the bug in this commit, then you tell Git just that: On the other hand, you might not see the bug. Then you use git bisect good. Telling Git whether a commit is bad or good tells Git which direction to keep searching in. If you say “bad”, Git knows to search in commits that came before the commit you are on. Otherwise, it will search commits that came after that one. Regardless, Git will simply repeat what it did when you started—check out another commit and give you a chance to keep inspecting commits till you finally home in on the commit that started the trouble. 
- Your Highlight on page 464 | location 7106 | Added on Tuesday, 23 January 2024 10:41:48


- Your Highlight on page 466 | location 7136-7180 | Added on Tuesday, 23 January 2024 10:45:12

Git provides a variety of useful tools to search the contents of repositories, the commit log, and commits. You can annotate any tracked file in a Git repository using git blame. This will show you, on a per-line basis, details about the latest commit that changed that line, including the commit ID, the author info, and the date the change was made. Most Git repository managers like GitHub make it easy to annotate files using git blame in your browser. You can supply git blame a specific commit ID to see the revision history of a file at the time that commit was made. You can search the contents of all tracked files in your repository using the git grep command. The git grep command by default is case-sensitive when searching. You can use the -i (shorthand for --ignore-case) flag to make your search case-insensitive. The git grep command also supports the -n (shorthand for --line-number) flag that will display the line number for a match. The git grep command lists every match it finds. You can restrict the output to list just the names of the files using the -l (shorthand for --name-only) flag. To find which commit added or removed a piece of text, you can use the -S flag that the git log command supports. The -S flag is one of two “pickaxe” options that Git supports, and it accepts as its argument the text you want to search for. The pickaxe options search the entire commit history but can be limited to inspect the history of a single file by supplying the name of the file to the git log command. The git log command can also display the patch introduced in every commit using the -p (shorthand for --patch) flag. This can be combined with the -S flag to see if the search text was added or removed in a particular commit. Searching for text in a Git repository using the -S flag only reveals commits that added or removed that piece of text. To find all commits where the line that contains a piece of text changed, there is the -G flag that git log supports. The --grep flag with the git log command searches commit messages. You can “flip back” to any commit in your commit history using the git checkout command. When you check out a commit, Git will rewrite your working directory to look like it did when you made that commit. Checking out a commit puts you in “detached HEAD” state. This means that you are no longer working on a branch. You can continue to make edits and commits, but switching away from that commit history means you will abandon your commits (since they are not referenced by a branch). It’s best not to make any commits when you are in detached HEAD state. Always work on branches. You can search for commits that introduced a typo or a bug using the git bisect command, which uses the binary search algorithm to navigate your commit history, and quickly zero in on the commit you are looking for. At each step in a git bisect session, Git checks out a commit, leaving you in detached HEAD state. Since Git will rewrite your working directory, you can look around to see if you spot the unwelcome behavior. Depending on whether you see the issue, you can tell Git if the current commit is “good” or “bad,” which informs Git which direction in the commit history to search. This repeats till you’ve isolated the commit with the reported issue.
- Your Highlight on page 484 | location 7419-7424 | Added on Tuesday, 23 January 2024 14:58:18

The global .gitconfig file What happens when you invoke the git config command with the --global flag? Git realizes you want a particular setting available across all of the repositories you work with, so it installs that setting in a file called .gitconfig in your home directory. For Linux and macOS users, your home directory will be ~/ and for Windows users, this defaults to the directory with your username under C:\Users. You can use your terminal to locate this file: 
- Your Highlight on page 487 | location 7458-7460 | Added on Tuesday, 23 January 2024 15:00:42

But then you decide to work on a personal project or contribute to an open source project in your free time. Just for that project, you would rather record your personal email address for every commit. Git allows you to install a specific configuration for a particular repository, overriding the global one. Let’s see how to do that next.
- Your Highlight on page 487 | location 7461-7470 | Added on Tuesday, 23 January 2024 15:01:19

Project-specific Git configuration The global Git configuration is a great place to store options that you want Git to use most of the time (like your name, which probably doesn’t change often). But every so often, you might prefer a different setting for a particular project. Git to the rescue—we can override global options for a particular project. The git config command supports another flag, --local, that writes a configuration file for a specific repository: Two points of note: the default behavior of the git config command is to install options locally. In other words, you can skip the --local flag and get the exact same behavior. You’d have to use the --global flag for it to not be a local install. Secondly, you have to be in a Git repository when you issue the git config command without the --global flag! Otherwise, Git will report a fatal: not in a git directory error. That makes sense—you are telling Git you want to set a specific option for a particular repository, the one you are in right now.
- Your Highlight on page 487 | location 7461-7472 | Added on Tuesday, 23 January 2024 15:01:50

Project-specific Git configuration The global Git configuration is a great place to store options that you want Git to use most of the time (like your name, which probably doesn’t change often). But every so often, you might prefer a different setting for a particular project. Git to the rescue—we can override global options for a particular project. The git config command supports another flag, --local, that writes a configuration file for a specific repository: Two points of note: the default behavior of the git config command is to install options locally. In other words, you can skip the --local flag and get the exact same behavior. You’d have to use the --global flag for it to not be a local install. Secondly, you have to be in a Git repository when you issue the git config command without the --global flag! Otherwise, Git will report a fatal: not in a git directory error. That makes sense—you are telling Git you want to set a specific option for a particular repository, the one you are in right now. NOTE Git stores the local configuration in a file called “config” inside the hidden .git folder.
- Your Highlight on page 487 | location 7461-7472 | Added on Tuesday, 23 January 2024 15:02:08

Project-specific Git configuration The global Git configuration is a great place to store options that you want Git to use most of the time (like your name, which probably doesn’t change often). But every so often, you might prefer a different setting for a particular project. Git to the rescue—we can override global options for a particular project. The git config command supports another flag, --local, that writes a configuration file for a specific repository: Two points of note: the default behavior of the git config command is to install options locally. In other words, you can skip the --local flag and get the exact same behavior. You’d have to use the --global flag for it to not be a local install. Secondly, you have to be in a Git repository when you issue the git config command without the --global flag! Otherwise, Git will report a fatal: not in a git directory error. That makes sense—you are telling Git you want to set a specific option for a particular repository, the one you are in right now. NOTE Git stores the local configuration in a file called “config” inside the hidden .git folder.
- Your Highlight on page 489 | location 7484-7488 | Added on Tuesday, 23 January 2024 15:03:10

Exactly! Git first reads the global configuration file (in your home directory), followed by the one local to your repository—in that order—and then merges them into one. Sections and keys that are unique to each file will remain untouched—however, if you have the user.email key set to a different value in your local configuration than what’s in the global one, the local one wins. Just think of the “distance” between each configuration and your repository—the closer it is, the higher its priority.
- Your Highlight on page 490 | location 7500-7506 | Added on Tuesday, 23 January 2024 15:04:02

The git config command offers an --unset flag that will remove an entry. Suppose you want to remove the value for user.email from the configuration of a specific repository—that is, you want to remove a “local” configuration. This is how you’d go about doing it: git config --local --unset user.email If this was a global configuration, you’d have to pass the --global flag alongside the --unset flag to affect the .gitconfig in your home directory. Also, recall that Git stores your configuration as a plain-text file. You can always choose to open the file using a text editor like Visual Studio Code and edit it. Be sure to make a backup first, though. (Better safe than sorry, right?)
- Your Highlight on page 491 | location 7515-7529 | Added on Tuesday, 23 January 2024 15:06:17

Listing your Git configuration Installing options and configuring Git to your whims is all fine and dandy, but sometimes you might just want to list everything you have configured. The git config command offers a --list flag that lists all the options you’ve set, global or local. Imagine you’ve set a bunch of options in the global configuration, and you’ve introduced a different email address using the git config with the --local flag. Here is what we see when we use the --list option on our own machine (yours will be different): As you can see, the --list flag lists all the options that Git sees, including some that Git sets up automatically. Recall that Git reads the global configuration first, followed by the local configuration. The --list flag lists the options in the order Git encounters them—entries at the top are global, followed by any local entries. You’ll notice that the previous listing displays user. email twice—the first is the value Git sees in the global configuration file; the second is the one that we installed locally in that repository. Naturally, you might be curious whether a particular option was set globally or locally. To answer that question the git config command supports another flag, --show-origin, which, alongside the --list option, will show you where Git picked up a particular setting. We aren’t done yet. We’ll soon show you another little trick that uses Git’s configuration capabilities. Stay tuned!
- Your Highlight on page 494 | location 7565-7573 | Added on Tuesday, 23 January 2024 15:09:03

To make this happen, you can install an alias: This is just another piece of configuration, and as you might’ve guessed, it gets stuffed in the .gitconfig file in your home directory. Everything you’ve learned so far about adding/editing/viewing the Git configuration also applies to aliases. Now, instead of having to type git log --oneline --graph --all, you simply invoke git loga and you get the exact same output! How awesome is that?! When you “set” an alias, the section in the .gitconfig file is called “alias” (which you must get right) and the key can be anything you want it to be. Just be sure to make the key relevant and somewhat memorable—in our case we picked loga because we are invoking the log command with the oneline, graph, and all flags, not to mention it’s pretty similar to log (with the “a” at the end).
- Your Highlight on page 495 | location 7589-7590 | Added on Tuesday, 23 January 2024 15:10:45

Finally, always make your aliases lowercase. This fits with how Git commands work—and they are easier to type.
- Your Highlight on page 496 | location 7591-7596 | Added on Tuesday, 23 January 2024 15:11:08

WATCH IT! Never define an alias name to match a Git command name! Let’s say you decide to define an alias, “log”, that expands into “log --oneline --graph”. Git will always look to see if there is a command called log before it looks to see if there is an alias called log. So, when you invoke git log, Git will find the log command and invoke that. In other words, you have no way of invoking the alias. Kinda defeats the purpose of having the alias to begin with, right?
- Your Highlight on page 501 | location 7668-7671 | Added on Tuesday, 23 January 2024 17:49:27

.gitignore file keeps untracked files out of your Git repository. Consider a hypothetical repository: NOTE Read that again—the .gitignore file is for untracked files only!
- Your Highlight on page 507 | location 7761-7767 | Added on Tuesday, 23 January 2024 18:01:11

As you might have guessed, ignoring operating-system-specific files can get repetitive, especially if you have many Git repositories. Each one will essentially list the same set of files again and again. Git allows you to define a global .gitignore file to avoid the repetition. For any project, Git will combine the global .gitignore file with any project-specific .gitignore file you provide to generate a complete list of files to ignore. Thie setup, as you might have guessed, involves tweaking the .gitconfig file in your home directory. Once you have some more experience with Git, we encourage you to explore this some more. Search online for the phrase “global gitignore” to get started.
- Your Highlight on page 510 | location 7820-7829 | Added on Tuesday, 23 January 2024 18:22:28

Here are some guidelines for writing a good commit message: Always use the imperative mood Avoid messages like “updated documentation” or “fixes login bug.” Write a commit message as if you were giving the computer a command, for example, “update documentation” and “fix intermittent bug when logging in.” NOTE We give credit where it’s due. This piece of advice comes from the prolific Tim Pope, published in a brilliant blog post that you can find here: https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html Avoid using the
- Your Highlight on page 510 | location 7820-7837 | Added on Tuesday, 23 January 2024 18:25:07

Here are some guidelines for writing a good commit message: Always use the imperative mood Avoid messages like “updated documentation” or “fixes login bug.” Write a commit message as if you were giving the computer a command, for example, “update documentation” and “fix intermittent bug when logging in.” NOTE We give credit where it’s due. This piece of advice comes from the prolific Tim Pope, published in a brilliant blog post that you can find here: https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html Avoid using the -m (or --message) flag with the git commit command Throughout this book, we’ve asked you supply commit messages to the git commit command using the -m flag. But you’re ready to level up. Our advice going forward is to simply invoke the git commit command with no flags. This will prompt Git to bring up Visual Studio Code or your default configured editor so you can type a message. You can use all of your text editor’s capabilities to craft a good commit message. You can even introduce double and single quotes, new lines, ampersands, and other characters that are notoriously hard to enter at the command line. In other words, with a text editor at your disposal you no longer have to wrestle with the limitations of the command line. 
- Your Highlight on page 512 | location 7840 | Added on Tuesday, 23 January 2024 18:25:24


- Your Highlight on page 512 | location 7841-7845 | Added on Tuesday, 23 January 2024 18:25:46

The most important thing to remember about a commit message is that it should focus on the why of a change, not the how or the what. Of course, this may not always be possible, but it’s a good ideal to keep in mind. Before we go further, it’s important to realize what this particular format buys you. You see, using the git log command with the --oneline flag will display the first line (header) for every commit. Here’s the log of the a-head-above repository you’ve been working with so far in this chapter:
- Your Highlight on page 513 | location 7851-7861 | Added on Tuesday, 23 January 2024 18:27:52

The anatomy of a good commit message: headers Let’s spend a few minutes dissecting our header, displayed here in its full glory: We’ll start with the type. We like to prefix our commit messages with the kind of change introduced in that commit. Here’s an abbreviated list of “types” we find useful: The commit type is usually obvious from the kind of task you’ve been assigned. You should work with your team to document a list of “types” so that everyone uses them consistently. The type is followed by a colon and a space, then the commit message describing the change (again, in imperative mood—that is, as if you are commanding the computer to take action on your part). Notice that our preference is to use all lowercase, unless we are spelling out acronyms (like CSS) or proper nouns (like Git). We usually end this by spelling out the ticket number (if there is one) wrapped in parentheses and prefixed with a hash mark.
- Your Highlight on page 514 | location 7870-7888 | Added on Tuesday, 23 January 2024 18:29:35

The anatomy of a good commit message: bodies Getting the header right is a very good first step, and a descriptive header is often sufficient to describe why a particular commit was made. But for many commits, a single-line header isn’t enough. Perhaps you wish to provide more information about the change or explain why you chose a particular approach. This is where the body of the commit message comes into play. Here’s the commit message we laid out for you a few pages ago: There is only one rule—you must separate the body from the header using a blank line. Outside of that, the guidelines for writing the body are pretty relaxed—it’s free-form text and can be as short or long as you need it to be. If you decide to write more than one paragraph, then be sure to insert a blank line between paragraphs. That’s it! What should you say? We have found ourselves writing blocks of text to further elaborate on a change or add links to online documentation or blog posts. Sometimes we link to past issues that were solved using a similar technique to establish precedent. We’ve even included what we did to test out our work, particularly if the testing setup was elaborate. Anything you think will help someone reading the commit log make sense of a change is fair game. NOTE We prefer using hyphens in place of asterisks when creating lists, and we encourage you to do the same. This aligns well with the Markdown format, which you’ve used throughout this book. There you have it! Go forth and write perfect commit messages. NOTE And if you make a mistake or a typo when you commit? Don’t forget about the --amend option, which you learned about in Chapter 4. Amend away!
- Your Highlight on page 516 | location 7900-7901 | Added on Tuesday, 23 January 2024 18:54:11

https://github.com/angular/angular
- Your Highlight on page 516 | location 7902-7903 | Added on Tuesday, 23 January 2024 18:54:20

https://www.conventionalcommits.org).
- Your Highlight on page 517 | location 7919-7935 | Added on Tuesday, 23 January 2024 18:55:51

We bet you’re wondering if we have any thoughts on the subject. Funny you should ask! Here’s how we suggest you name your branches: We mentioned in Chapter 2 that Git allows forward slashes in branch names. We recommend using them to separate the different parts of the branch name. Let’s take a look at each segment of the branch name: rg Prefix the name of the branch with your initials. This makes it easy to discern who created which branches when you list them (using the git branch command with the -a or --all flag). 1618 We have always recommended that you check your Git status before adding files to the index or making commits. Since Git always displays the branch name in the output of the git status command, which will now include the ticket number, you’ll always have it when you’re about to commit. No need to dig up your notes or fire up the task tracking tool—it’s right there! remove-typos-in-documentation Finally, we arrive at a brief description of the task at hand. We usually just grab the title of the ticket, lowercase it, convert the spaces to hyphens, and remove any superfluous words. Done! By incorporating a clear (but short) description of the task, we leave ourselves a mental bookmark. If we have to switch tasks, this will make it easier for us to remember what we were working on when we come back.
- Your Highlight on page 520 | location 7973-7990 | Added on Tuesday, 23 January 2024 19:11:00

 Features: Free. Available for macOS and Windows We’ve used Sourcetree, a brilliantly designed Git GUI, for years, and highly recommend it. We’ll discuss it more on the next page. URL:  https://www.sourcetreeapp.com   GitHub Desktop   Features: Free. Available for macOS and Windows GitHub’s official desktop app makes working with Git and GitHub easier. It allows you to fork repositories, create and view pull requests, and do plenty of things that are specific to GitHub. If you use GitHub as your repository manager, GitHub Desktop might just be the GUI tool you are looking for. URL:  https://desktop.github.com   Gitlens   NOTE Any editor worth its salt will have a plug-in or extension for Git.
- Your Highlight on page 526 | location 8052-8084 | Added on Tuesday, 23 January 2024 19:15:05

Git is extremely customizable. You can set and override many settings using the git config command. The git config command, used with the --global flag, allows you to create settings that affect every repository you work in on that particular workstation. Using the git config command, you can set the value for a particular setting. All global settings are stored in a file called .gitconfig, which is stored in the home directory under your account. It consists of sections, and keys under a section, each associated with a value. You’ll have to configure some settings, like user.name and user.email, to be able to use Git. Others, like core.editor, override Git’s defaults and are optional. You can store certain settings at the repository level (that is, local to a specific repository) using the --local flag with the git config command. To list all settings, use the git config command with the --list option. Git allows you to create aliases, which act like shortcuts to invoke certain Git commands. Aliases can also include flags and arguments. Aliases are configurations, under the “alias” section. The key can be any word, and its value is what the alias will expand to. You can invoke an alias like you would any Git command (e.g., git loga). Most, if not all, projects require that some files never be committed. You can tell Git to ignore an untracked file. Once ignored, it will remain forever untracked. To tell Git to ignore a file, create a .gitignore file at the root of your repository that lists all the files you wish to ignore. “Commit early, commit often” is the mantra when it comes to working with Git. Recording snapshots of your work regularly is a good habit to develop. Think of each commit in terms of its scope, not its size. Try to group changes together logically. Use consistent and informative commit messages. This can be helpful when reading the output of the git log command or searching for a commit using git bisect (see Chapter 7), to name a few examples. Create contexual and meaningful branch names that help discern which branches are yours and what their purposes are. Consider using a graphical user interface (GUI) tool to aid in your work with Git. Remember, it’s not one or the other—you can and should use a GUI side by side with the command line.
- Your Highlight on page 539 | location 8264-8280 | Added on Tuesday, 23 January 2024 20:59:28

#1 Tags (remember me forever) You know that Git branches are sticky notes—a branch is simply a named reference to a commit. You also know that if you make a new commit on a branch, Git moves the branch to point to the new commit ID on that branch. Tags, like branches, are also named references to commits, except that once they are created, they never move. Tags are very useful if you want to name a commit so you can find and get it to easily. We use tags to record “landmarks” in a project history. For example, we could tag the commit that marks a specific version of our software, like v1.0.0. Or the commit that fixed a particularly nasty bug. To create a tag, Git offers the git tag command: By default, the tag command will record the current ID (that is, where HEAD points to) in the tag. However, you can supply a specific commit ID after the tag name. Tag names follow the same rules as branch names. They don’t allow spaces (we like using hyphens instead), but they can have forward slashes and periods. To list all the tags in your repository, you can simply supply the -l (lowercase “L,” which is shorthand for --list) flag to the git tag command. Tags, like branches, are part of your commit history, and you can fetch (and push) tags from the remote to share them with the rest of your team. Both the fetch and push command support the --tags flag. Supplying this flag ensures that the commit history for everyone working on a shared repository accurately reflects all tags that are part of your commit history. NOTE The git pull command also supports the --tags flag.
- Your Highlight on page 539 | location 8264-8285 | Added on Tuesday, 23 January 2024 20:59:57

#1 Tags (remember me forever) You know that Git branches are sticky notes—a branch is simply a named reference to a commit. You also know that if you make a new commit on a branch, Git moves the branch to point to the new commit ID on that branch. Tags, like branches, are also named references to commits, except that once they are created, they never move. Tags are very useful if you want to name a commit so you can find and get it to easily. We use tags to record “landmarks” in a project history. For example, we could tag the commit that marks a specific version of our software, like v1.0.0. Or the commit that fixed a particularly nasty bug. To create a tag, Git offers the git tag command: By default, the tag command will record the current ID (that is, where HEAD points to) in the tag. However, you can supply a specific commit ID after the tag name. Tag names follow the same rules as branch names. They don’t allow spaces (we like using hyphens instead), but they can have forward slashes and periods. To list all the tags in your repository, you can simply supply the -l (lowercase “L,” which is shorthand for --list) flag to the git tag command. Tags, like branches, are part of your commit history, and you can fetch (and push) tags from the remote to share them with the rest of your team. Both the fetch and push command support the --tags flag. Supplying this flag ensures that the commit history for everyone working on a shared repository accurately reflects all tags that are part of your commit history. NOTE The git pull command also supports the --tags flag. One thing to watch out for—try to avoid naming a tag the same name as a branch. Much like we encourage putting your initials in branch names, we encourage finding appropriate prefixes for tag names. We like using the letter “v” (for “version”) to label version numbers. SERIOUS CODING A tag, like a branch, is a named reference to a commit. As long as you have a tag pointing to a commit, it will always be reachable, even if it has no branch or child commit pointing to it.
- Your Highlight on page 541 | location 8286-8310 | Added on Tuesday, 23 January 2024 21:07:08

#2 Cherry-pick (copying commits) Imagine you’re working on a new feature and notice a bug in the code. You fix the bug and make a commit (preferably prefixed with the “type” “fix”). Then you learn that your teammates are getting affected by the same bug. Your branch includes the fix, but you aren’t ready to merge your branch in just yet. So what’s to be done? The commit that contains the bug fix is on your feature branch—how can you apply just that fix to the integration branch? NOTE In case you were wondering where you heard the term cherry-pick before, we mentioned it in Chapter 3. You have two options. First, you could create a new branch based on the integration branch, manually reapply your bug fix, commit, and issue a pull request. Second, you could use another Git command, called cherry-pick, which allows you to copy a commit to another branch. Since you want the fix to be on the master branch, you’d first switch to the master branch. Let’s see how this would play out: Having the ability to cherry-pick commits does not mean you shouldn’t create a feature branch to apply your work, nor does it mean avoiding your team’s conventions around how that change is applied to the integration branch (issue a pull request or merge locally and push). It does, however, avoid you having to redo a change manually—you can rely on Git’s memory to confidently apply the changes introduced in a commit by simply asking it to copy them to a new location in your commit history. Note that you can get a merge conflict since Git will replay your changes on the master branch. Recall that when calculating the commit ID, Git uses the commit’s parent commit ID. This means that the cherry-picked commit will have a different commit ID than the original. This is yet another reason why separating your work into different types of commits is a good idea. You never know when you might have to reach and copy a commit over to another branch. WATCH IT! Don’t overuse cherry-picking! The best way to integrate your work is to merge your feature branch into the integration branch. Cherry-picking commits should be only used as a last-ditch effort, in situations where you absolutely can’t merge the branch where the work was done. Remember, when you are cherry-picking commits, you are making copies of those commits, which contain the same set of changes as the original. Doing this too often can make it hard to decipher your commit history.
- Your Highlight on page 542 | location 8311-8348 | Added on Tuesday, 23 January 2024 21:10:35

#3 Stashes (pseudo-commits) You are knee deep in work. You’ve edited a bunch of files, maybe even added a few files to the index. You check your status and realize you are on the wrong branch! Oops. You should have been on your feature branch, but instead you’re on the master branch. Recall that when you switch branches, Git will rewrite your working directory to look like it did when you made the most recent commit on that branch. This means that if you’ve modified a file that looks different in the two branches, Git won’t let you switch because it would have to overwrite your changes. How can you switch branches now that you have a few changes in flight? Git allows you to stash away your changes using the git stash command. When you ask Git to stash your changes, Git stuffs them away in a special location. This leaves your working directory clean. You can now switch branches. NOTE Recall all those times when someone asked you to clean your room? You take everything in sight, shove it all in a drawer, and ta-da! Clean room. See, you’re already an expert in stashing. You can think of a stash as a sort of pseudo-commit. The difference is that stashing records the changes in both your working directory and the index, as opposed to a commit, which only records what is in your index. The other difference is that a commit adds to your commit history, while a stash does not. If you push, your stashes don’t go along for the ride—they remain in your local Git repository. NOTE This is important. Stashes are local to your repository and are not designed to be shared. So now that you’ve stashed your changes—how do you get them back? You switch branches, and now you’d like you all that work you stashed away back (pretty please with sugar on top). When you stash something, Git puts your work in a stack. This allows you to create multiple stashes, and much like a stack of pancakes, your latest stash created will be at the top. Git allows you to “pop” a stash. This means asking Git to take the topmost (latest) stash, recover all the changes recorded in it, and bring them back, just as they were recorded in the stash. NOTE Mmm...pancakes. NOTE This is often referred to as a “last in, first out” (LIFO) structure. Git diligently remembers which changes were in the index and which were in the working directory, and it puts them back. Now that you are on the right branch and those changes you made are in the right place, you can get back to work! There’s a lot more to stashes—you can supply them with a commit message (just like a standard commit message), list them, view the changes you’ve put in them and even apply specific stashes (rather than just popping the last one you created). And while stashing, by default, only stows away any changes to tracked files, Git allows you to pick whether you want all files (tracked and untracked), only files in the index, or even individual files. WATCH IT! Don’t overuse stashes It’s tempting to use stashes to store “work in progress” items. Sometimes stashes may seem like a good way to stuff away some work while you try an alternative approach to solving a problem. But you already have a solution for this exact problem: branches! We’ll admit—we don’t use stashes very often. (That’s why they are in the appendix of this book!) One of the times we reach for them is when we are faced with the exact scenario we just described, where we’ve made some edits, haven’t committed just yet, and find ourselves on the wrong branch.
- Your Highlight on page 545 | location 8349-8367 | Added on Tuesday, 23 January 2024 21:13:14

#4 reflog (reference log) You know that every time you switch branches or check out a specific Git commit using the git checkout command, HEAD moves. You also know that when you make a commit on a branch, both the branch and HEAD move to the new commit on that branch. What happens when you do a reset? HEAD moves to the commit you reset to. Turns out, a lot of operations involve HEAD, like moving around in Git repositories, or adding to (or removing from) your commit history. Git maintains a log called the reflog (short for reference log), which is updated every time HEAD moves. You can see the reflog for any repository using the git reflog command: Looking closely at one entry in the reflog, we can discern a lot about what happened: Reading the reflog and getting used to all the information Git records in it can take a little. However, it’s important because the reflog is your safety net. Suppose you reset a commit (which might make a commit unreachable) and then change your mind. Well, since the git reset command moves both HEAD and the branch pointer, the reflog can tell you where you were before you reset. Here’s another example: say you are in detached HEAD state. You switch away to another branch or commit, but now you can’t recall which commit you had checked out previously. Reflog to the rescue! Stashes and the reflog have a lot in common. Like the stashes list, the reflog is maintained last-in, first-out (LIFO): the latest movement of HEAD is listed at the top. If you were to make another commit or switch branches, that would be inserted at the top of the list, and the current topmost item would move down one. Another thing stashes and the reflog share is that the reflog, like your stashes, is local to your repository—it is not shared. While the reflog isn’t something you’ll use a lot in your day-to-day work with Git, it is certainly a powerful ally if you ever find yourself in a pickle. So stay calm and use reflog.
- Your Highlight on page 546 | location 8367-8402 | Added on Tuesday, 23 January 2024 21:18:08

#5 rebase (another way to merge) Merging branches is an integral part of working with Git. A merge unites work from separate branches. You know that when you merge two branches, you can either get a fast-forward merge (where the proposing branch jumps forward) or a merge commit. Git offers another way to merge your work: rebase. Before we dive into the details of what rebase offers us and how it is different than doing a merge, let’s consider a hypothetical scenario: suppose you are working on a feature branch (rg/feat-a in this case) and are ready to merge. However, your feature branch and the integration branch (master) have diverged. You already know what will happen if you merge your feature branch into the integration branch—you’ll get a merge commit: Here, the merge commit (E), which Git created, represents the union of the work that happened in the two branches. What if, instead of creating a branch off commit A, you had created the rg/feat-a branch branch after commit B (on the master branch) had already been created? In other words, you do the same work (same diff) in commits C and D, but instead of building off commit A, you build your work on top of commit B? If you think about it, commit D′ (D prime) is effectively the union of the work in the master and the rg/feat-a branch, because it started with everything the master branch had to offer! That is, D′ is the merge of the master and feat-a branches. NOTE If you were to merge rg/feat-a into the master branch, it would be a fast-forward merge, which further solidifies our argument. And this is exactly what Git’s rebase capability allows you to do—it allows you to merge two branches by moving one branch on top of another, effectively merging the two without actually merging. When you rebase one branch onto another, you are asking Git to replay all the commits on the current branch on top of the latest commit on the other branch. Perhaps this is best explained by an example—let’s revisit the one example from the previous page: Performing a rebase involves another Git command, called git rebase. You start by switching to the branch you want to rebase—rg/feat-a branch in this case. If you rebase this branch on master, Git iterates over all the commits in the feature branch, starting with the first commit (C). It records a new commit (C′) that has the same changes contained in commit C, except the new commit’s parent will be B (as opposed to A). It then proceeds to the next commit on the feature branch, D in this case, and records a new commit (D′) with the same changes as D—except its parent will be the C′. It does this till all the commits have been re-recorded, then it moves the feature branch to point to the latest commit (D′). Note that the branch being rebased moves to the newly recorded commit (D′), as opposed to merging, where the proposing branch moves to the merge point. As you can see, there are a few differences between merging and rebasing. Your history is very different. Rebasing “flattens” the history—you end up with a straight line, with C′ being the parent of D′, B being the parent of C′, and so forth. Rebasing is also more involved than merging, since Git rewrites your commits, which changes their IDs, as opposed to merging, which leaves commit IDs the same. This means that you should not rebase public commits. If merging and rebasing have the same results, which one should you reach for when aiming to integrate your work? Merging is much more straightforward and does not involve Git having to rewrite your commit history. This means you can safely merge branches, even those with public commits. Since you are just learning the ropes, use merges. As you get more familiar with Git, and the different kinds of workflows that teams use, you can decide whether you should merge or rebase.
- Your Highlight on page 548 | location 8403-8404 | Added on Tuesday, 23 January 2024 21:18:20

https://i-love-git.com
